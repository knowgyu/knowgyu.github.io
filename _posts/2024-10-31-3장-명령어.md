---
title: "3장 명령어"
author: knowgyu
description: " "
date: 2024-07-16 06:53:31 +0900
categories: [Computer Science, 혼자 공부하는 컴퓨터구조+운영체제]
tags: [컴퓨터구조, 운영체제]
---

명령어란 무엇이고, 어떻게 생겼으며, 컴퓨터를 어떻게 작동시키는지 알아봅니다.

# 3-1 소스 코드와 명령어

키워드 : 고급 언어, 저급 언어, 기계어, 어셈블리어, 컴파일 언어, 인터프리터 언어

---

개발자가 프로그래밍 언어로 작성한 소스 코드가 컴퓨터 내부에서 명령어가 되고 실행되는 과정에 대해 다룹니다.

## 고급 언어와 저급 언어

- 고급 언어(high-level programming language):
    
    우리가 프로그램을 만들 때 사용하는 프로그래밍 언어(C/C++, Java, Python)은 컴퓨터가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어
    

- 저급 언어(low-level programming language):
    
    컴퓨터가 직접 이해하고 실행할 수 있는 언어.
    
    저급 언어는 명령어로 이루어져 있음.
    

고급 언어로 작성된 소스 코드가 실행되려면 저급 언어, 즉 명령어로 변환되어야 합니다.

### 저급 언어

저급 언어는 기계어와 어셈블리어, 두 종류가 있습니다.

**기계어**란 0과 1 명령어 비트로 이루어진 언어입니다.

(0과 1 혹은 16진수로 표현하기도 함)

하지만, 이렇게 0과 1로 이루어진 기계어를 보면 어떻게 작동하는 지 알아보기 어렵습니다.

그래서 등장한 저급 언어가 **어셈블리어** 입니다.

즉 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어가 어셈블리어

| **기계어**  | **어셈블리어** |
| ----------- | -------------- |
| `0101 0101` | `push rbp`     |
| `0101 1101` | `pop rbp`      |
| `1100 0011` | `ret`          |

하지만, 어셈블리어를 이용해 복잡한 프로그램을 만들기는 쉽지 않습니다.

→ 고급 언어의 필요성!

> “그렇다면, 저급 언어를 알아야 할 필요가 있나요? 고급 언어로 소스 코드를 작성하면 알아서 저급 언어로 변환되어 잘 실행되는데, 일부러 저급 언어로 개발할 일은 없지 않나요?”
> 

개발자에 따라 다름.

하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등의 개발자는 어셈블리어를 알아야하며, 이를 이용해 프로그램을 만드는 경우가 있음.

> 즉, 어떤 개발자가 되냐에 따라 다르지만, 하드웨어와 밀접할 수록 저급 언어를 알아야 하며, 고급 언어와 저급 언어의 차이를 이해하는 것 자체가 매우 좋은 교양이기에 반드시 알아두는 것이 좋습니다.
{: .prompt-tip}

## 컴파일 언어와 인터프리터 언어

그렇다면, 고급 언어는 어떻게 저급 언어로 변환될까요?

크게 두 가지, **컴파일**방식과 **인터프리트**방식이 있습니다.

### 컴파일 언어

컴파일 언어는 **컴파일러**에 의해 소스 코드 **전체**가 저급 언어로 변환되어 실행되는 고급 언어!

대표적으로는 C/C++

고급 언어(소스 코드.c) → **컴파일(컴파일러)** → 저급 언어(목적 코드.o)

### 인터프리터 언어

인터프리터 언어는 **인터프리터**에 의해 소스 코드가 **한 줄씩** 실행되는 고급 언어!

대표적으로는 Python

즉, N번째 줄에 오류가 있는 상황에서 컴파일 언어는 컴파일에 실패하지만, 인터프리터 언어는 N-1번째 줄까지는 올바르게 수행되며 N번째 줄에서 오류가 발생함.

> 컴파일 언어와 인터프리터 언어, 명확하게 구분될까?
>
> C,C++과 같이 명확하게 구분할 수 있는 언어도 있으나, 현대의 많은 언어들은 그 경계가 모호한 경우가 많음. 대표적인 인터프리터 언어인 Python도 컴파일을 하지 않는 것은 아니며, Java의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행함.
>
> 즉, 둘 중 하나의 방식으로만 작동되진 않으며, ‘고급 언어가 저급 언어로 변환되는 대표적인 방법에는 컴파일과 인터프리트가 있다’ 정도로만 이해하는 것이 좋음.
{: .prompt-tip }

### 목적 파일 vs 실행 파일

이미지로 이루어진 파일 = 이미지 파일(.jpg)

텍스트로 이루어진 파일 = 텍스트 파일(.txt)

목적 코드로 이루어진 파일 = **목적 파일(.o)**

실행 코드로 이루어진 파일 = **실행 파일(.exe)**

목적 파일도 저급 언어로 이뤄져있지만, 목적 파일 ≠ 실행 파일

목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 함.

예를 들어, `helper.c` 와 `main.c` 라는 두 개의 소스 코드가 있음.

1. `helper.c` 에는 `HELPER_더하기` 라는 기능이 구현되어 있음.
2. `main.c` 에는 `helper.c`에 구현된 기능과 ‘화면 출력’이라는 기능이 있음.

- `main.c`
    
    ```markdown
    helper.c에 있는 HELPER_더하기
    
    화면_출력
    ```
    
- `helper.c`
    
    ```markdown
    HELPER_더하기
    ```
    

이들을 컴파일하면 각각 목적 코드가 생길 것!(`main.o`, `helper.o`)

하지만, `main.o`는 `HELPER_더하기`에 대해 모르기에, 바로 실행할 수 없음.

즉, `main.o`에 없는 외부 기능들을 연결 짓는 작업이 필요한데 이게 **링킹!(linking)**

# 3-2 명령어의 구조

키워드 : 명령어, 연산 코드, 오퍼랜드, 주소 지정 방식

---

명령어의 구조와 주소 지정 방식을 학습하며 명령어의 생김새와 작동 원리 이해하기

## 연산 코드와 오퍼랜드

명령어는 연산 코드와 오퍼랜드로 구성되어 있음.

| **작동(or 연산)** | **연산에 사용할 데이터(or 저장된 위치)** | **연산에 사용할 데이터(or 저장된 위치)** |
| ----------------- | ---------------------------------------- | ---------------------------------------- |
| 더해라            | 100과                                    | 120을                                    |
| 빼라              | 메모리 32번지 안의 값과                  | 메모리 33번지 안의 값을                  |
| 저장해라          | 10을                                     | 메모리 128번지에                         |

연산 코드 = 연산자

여기서 맨 왼쪽을 “연산 코드” 그리고 오른쪽을 “오퍼랜드”라고 합니다.

오퍼랜드 = 피연산자

어셈블리어 예시

```nasm
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-4], 1
...
```

여기서 왼쪽의 `push`, `mov`가 연산, 오른쪽이 오퍼랜드

### 오퍼랜드

오퍼랜드는 ‘연산에 사용할 데이터’ 혹은 ‘연산에 사용할 데이터가 저장된 위치’를 의미함.

그래서 오퍼랜드 필드에는 숫자와 문자 등 데이터 값 혹은 메모리나 레지스터 주소가 올 수 있음.

하지만, 보통 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담기기에 오퍼랜드 필드 = 주소 필드


> 여기서, 오퍼랜드가 하나도 없으면 0-주소 명령어, 오퍼랜드가 1개면 1-주소 명령어, …
{: .prompt-info }

### 연산코드

연산 코드의 종류는 많지만, **기본적인** 연산 코드는 네 가지

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

## 주소 지정 방식

오퍼랜드 필드에 직접적인 값이 아닌, 주소를 사용하는 이유는?

**명령어의 길이 때문!**

하나의 명령어가 n비트고, 그중 연산 코드 필드가 m비트라면

→ n-m비트만큼 오퍼랜드 필드 사용 가능.(피연산자가 1개든 2개든 3개든)

이로 인해, 오퍼랜드 필드에 표현할 수 있는 정보의 수는 매우 적어짐

메모리 주소를 담는다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지기에, 데이터의 주소를 담는다!

또한, 메모리 주소가 아닌 레지스터 이름을 명시할 때도 똑같음.

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 **“유효 주소”** 라고 한다!

이처럼 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식(addressing mode)**이라고 함.

### 즉시 주소 지정 방식

오퍼랜드 필드에 연산에 사용할 **데이터**를 명시하는 방식!

데이터의 크기가 작아지는 단점은 있지만, 데이터를 찾는 과정이 없기에 빠르다!

### 직접 주소 지정 방식

오퍼랜드 필드에 **유효 주소**를 명시하는 방식!

데이터의 크기는 커졌지만, 여전히 유효 주소를 표현할 수 있는 칸이 연산 코드로 인해 제한됨

### 간접 주소 지정 방식

오퍼랜드 필드에 **유효 주소의 주소**를 명시하는 방식!

직접 주소 지정 방식보다 표현할 수 있는 범위는 넓어졌지만, 두 번의 메모리 접근으로 인해 일반적으로 느린 방식!

### 레지스터 주소 지정 방식

오퍼랜드 필드에 데이터가 담긴 **레지스터 이름**을 명시하는 방식!

직접 주소 지정 방식과 유사함. 메모리보다 레지스터에 접근하는 것이 더 빠르기에 더 빠르게 접근!

하지만, 직접 주소 지정 방식과 동일한 문제를 갖고 있음.

### 레지스터 간접 주소 지정 방식

오퍼랜드 필드에 연산에 사용할 **데이터의 위치를 담은 레지스터를 명시**하는 방식!

간접 주소 지정 방식과 유사함. 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점이 있음. 그리고 메모리보다는 레지스터 접근이 빠르기에 간접 주소 지정 방식보다 빠름

## +) 스택과 큐

스택은 LIFO(리포) Last In First Out

큐는 FIFO(피포) First In First Out

---
---
---

> 위 내용은 한빛미디어의 "혼자 공부하는 컴퓨터 구조+운영체제" 교재를 학습하고, 정리한 글입니다.
{: .prompt-tip }
