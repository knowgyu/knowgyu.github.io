---
title: "4장 CPU의 작동 원리"
author: knowgyu
description: " "
date: 2024-10-31 06:53:35 +0900
categories: [혼공컴운]
tags: [컴퓨터구조, 운영체제]
---

CPU를 구성하는 부품들의 이름과 역할, 그리고 명령어를 실행하는 방식

# 4-1 ALU와 제어장치

키워드 : ALU, 플래그, 제어장치, 제어 신호

---

CPU는 메모리에 저장된 명령어를 읽고, 해석하고, 실행하는 장치

CPU 내부에는

- ALU : 산술/논리 계산 담당
- 제어장치 :  명령어를 읽고 해석하는 장치
- 레지스터 : 작은 임시 저장 장치

## ALU

**ALU가 받는 정보는?**

ALU는 레지스터를 통해 **피연산자**를 받아들이고, 

제어장치로부터 수행할 연산을 알려주는 **제어신호**를 받아들임.

**ALU가 내보내는 정보는?**

특정 숫자나 문자, 메모리 주소가 될 수 있음.(+플래그)

결괏값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장!

**플래그?**

이진수만으로는 음수인지 양수인지 판단하기 어렵기에 추가적인 정보!

| **플래그 종류**   | **의미**                           |
| ----------------- | ---------------------------------- |
| 부호 플래그       | 연산 결과의 부호                   |
| 제로 플래그       | 연산 결과가 0인지                  |
| 캐리 플래그       | 연산 결과 올림수나 빌림수가 있는지 |
| 오버플로우 플래그 | 오버플로우 발생여부                |
| 인터럽트 플래그   | 인터럽트가 가능한지                |
| 슈퍼바이저 플래그 | 커널 OR 사용자모드 구분            |

플래그들은 **플래그 레지스터**에 저장!

## 제어장치

제어 신호를 내보내고, 명령어를 해석하는 부품

**제어 신호**는 컴퓨터 부품을 관리하고 작동시키기 위한 일종의 전기 신호

### **제어장치가 받아들이는 신호는?**

### 1. 클럭

클럭(clock)이란 컴퓨터 연산의 시간 단위

클럭에 맞춰 레지스터에서 다른 레지스터로 이동하거나, 연산을 수행하는 등

### 2. 해석해야 할 명령어

CPU가 해석해야 할 명령어는 **명령어 레지스터**라는 특별한 레지스터에 저장!

제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤,

제어 신호를 발생시킴

### 3. 플래그 레지스터 속 플래그 값

### 4. 제어 버스(시스템 버스 中)로 전달된 제어 신호

### 제어장치가 내보내는 신호는?

### CPU 외부에 전달 or CPU 내부에 전달

외부에 제어 신호를 전달한다는 것은 제어 버스로 제어 신호를 내보낸다는 것!

크게 메모리에 전달 OR 입출력장치에 전달

# 4-2 레지스터

키워드 : 프로그램 카운터, 명령어 레지스터, 메모리 주소/버퍼 레지스터, 범용/플래그 레지스터, 스택 포인터, 베이스 레지스터

---

프로그램 속 명령어와 데이터는 실행 전후로 **반드시 레지스터에 저장**

즉, 레지스터를 통해 프로그램 실행 시 cpu에서 어떻게 동작하는 지 알 수 있다!

## 반드시 알아야 할 레지스터

상용화된 cpu 속 레지스터들은 각자 다르다.

하지만, 공통으로 포함하는 8개의 레지스터에 대해 학습!

### 1. 프로그램 카운터(Program Counter)

메모리에서 가져올 명령어의 주소, 즉, 메모리에서 읽어 들일 명령어의 주소를 저장!

프로그램 카운터를 명령어 포인터(IP)라고 부르는 CPU도 있음.

### 2. 명령어 레지스터(Instruction Register)

해석할 명령어, 즉, 방금 메모리에서 읽어 들인 명령어를 저장!

제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤 제어 신호를 보냄

### 3. 메모리 주소 레지스터(MAR:Memory Address Register)

메모리의 주소를 저장하는 레지스터

CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거쳐감.

### 4. 메모리 버퍼 레지스터(Memory Buffer Register)

메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터

즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침

CPU가 주소 버스로 내보낼 값이 3번 레지스터를 지난다면,

데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침

### 예시!

1. CPU로 실행할 프로그램이 1000~1500번지에 저장되어 있는 상황.
2. 프로그램 실행을 위해 **프로그램 카운터**에 1000이 저장됨
3. 프로그램 카운터의 1000값을 메모리 주소 레지스터에서 받아와 저장(주소를 저장)
4. 제어 장치에서 ‘메모리 읽기’ 신호를 주소 버스를 통해 내보냄.
5. 데이터 버스를 통해 1000번지에 있는 값 0xB1이 메모리 버퍼 레지스터로 전달
+ 프로그램 카운터는 1 증가하여 1001로
6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동(0xB1)
7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호 발생

### 5. 범용 레지스터(general purpose register)

다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터

범용 레지스터는 데이터와 주소 모두를 저장할 수 있음

### 6. 플래그 레지스터(flag register)

ALU 연산 결과에 따른 플래그를 저장하는 레지스터

연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

## 특정 레지스터를 이용한 주소 지정 방식 : 스택 주소 지정

**스택 주소 지정 방식**은 스택과 스택 포인터를 이용한 주소 지정 방식!

스택은 가장 최근에 저장한 값부터 꺼내는데,

여기서 스택의 꼭대기를 가리키는 **스택 포인터**라는 레지스터가 있음.

즉, 스택 포인터는 스택에 마지막으로 저장된 값의 위치를 저장하는 레지스터


> 그럼 스택은 어디에?
>
>메모리 영억에 스택처럼 사용할 영역이 정해져 있음.
>→ 스택 영역!
>
>다른 주소 공간과는 다르게 암묵적으로 약속된 영억
{: .prompt-tip }

## 특정 레지스터를 이용한 주소 지정 방식 :  변위 주소 지정

> 명령어 = 연산코드 + 오퍼랜드
> 오퍼랜드 필드에는 메모리 주소가 담길 때도 있음
{: .prompt-info }

**변위 주소 지정 방식**이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더해

유효 주소를 얻어내는 주소 지정 방식!

오퍼랜드 필드의 주소와 어떤 레지스터를 더하는 지에 따라

- 상대 주소 지정 방식
- 베이스 레지스터 주소 지정 방식

으로 나뉨.

### 상대 주소 지정 방식

오퍼랜드와 프로그램 카운터의 값을 더해 유효 주소를 얻는 방식

만약 오퍼랜드가 -3이였다면, 프로그램 카운터에 -3을 한

즉, 실행하기로 했던 주소에서 3번째 이전 번지로 가서!

### 베이스 레지스터 주소 지정 방식

오퍼랜드와 베이스 레지스터의 값을 더해 유효 주소를 얻는 방식

여기서 베이스 레지스는 ‘기준 주소’, 오퍼랜드는 ‘기준 주소로부터 떨어진 거리’

# 4-3 명령어 사이클과 인터럽트

키워드 : 명령어 사이클, 인터럽트, 예외, 하드웨어 인터럽트, 인터럽트 서비스 루틴

---

CPU가 명령어를 처리하는 과정에는 정해진 흐름이 있고, 그 흐름을 반복하며 처리

이렇게 하나의 명령어를 처리하는 정형화된 흐름을 **명령어 사이클** 이라 함

간혹, 이 흐름을 끊어지는 상황이 있는데, 이것이 바로 **인터럽트**!

## 명령어 사이클

명령어 사이클 = 인출 사이클(데이터가져오기) + 실행 사이클(연산하고 제어신호보내기)

하지만, 메모리에 접근이 필요할 경우 **간접 사이클**을 거쳐가기도 함

## 인터럽트

CPU가 수행 중인 작업을 방해해 잠시 중단하는 신호를 **인터럽트**라 한다!

**인터럽트 = 동기 인터럽트 + 비동기 인터럽트**

**동기 인터럽트**란 CPU에 의해 발생하는 인터럽트

CPU가 명령어 수행 중, 오류와 같은 예외 상황을 마주쳤을 때 발생!

(예외exception이라 부르기도 함)

**비동기 인터럽트**는 주로 입출력장치에 의해 발생하는 인터럽트!

세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할을 함

(하드웨어 인터럽트라 부르기도 함)

**하드웨어 인터럽트**

알림과 같은 인터럽트. 입출력 도중에도 효율적으로 명령어를 처리하기 위해 사용

명령을 시켜놓고 주기적으로 확인할 필요 없기에, 효율적으로 명령어 처리 가능!

**하드웨어 인터럽트 처리 순서**

1. 입출력장치는 CPU에 인터럽트 요청 신호 보냄
2. CPU는 실행 사이클이 끝나고 명령어 인출 전 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인하고 **인터럽트 플래그**를 통해 받을 수 있는지 확인
4. 가능하다면 CPU는 지금까지의 작업을 백업
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
6. 인터럽트 서비스 루인이 끝나면, 4에서 백업한 작업을 복구해 실행 재개

# 추가(예외의 종류)

---

예외의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있습니다.

**인터럽트**

1. **동기 인터럽트(예외)**
    1. **폴트**
    2. **트랩**
    3. **중단** : 프로그램을 강제 중단시킬 수밖에 없는 심각한 오류!
    4. **소프트웨어 인터럽트** : 시스템 콜 발생 시
2. **비동기 인터럽트(하드웨어 인터럽트)**

### 폴트 vs 트랩

폴트 : 예외를 처리한 직후 **예외가 발생한 명령어**부터 실행을 재개하는 예외

트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 **다음 명령어부터** 실행을 재개

---
---
---

> 위 내용은 한빛미디어의 "혼자 공부하는 컴퓨터 구조+운영체제" 교재를 학습하고, 정리한 글입니다.
> {: .prompt-tip }
