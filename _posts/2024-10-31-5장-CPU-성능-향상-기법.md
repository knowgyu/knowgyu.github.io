---
title: "5장 CPU 성능 향상 기법"
author: knowgyu
description: " "
date: 2024-08-25 06:53:46 +0900
categories: [혼공컴운]
tags: [컴퓨터구조, 운영체제]
---

클럭과 코어, 스레드라는 개념을 학습하고, 빠른 CPU를 만드는 설계 기법인 멀티코어와 멀티스레드에 대해 배웁니다

# 5-1 빠른 CPU를 위한 설계 기법

키워드 : 클럭, 코어, 멀티코어, 스레드, 멀티스레드

---

## 클럭

1. 컴퓨터 부품들은 “클럭 신호”에 맞춰 동작합니다.
2. CPU는 “명령어 사이클”이라는 정해진 흐름에 맞춰 명령어를 실행합니다.

즉, 클럭 속도(Hz)가 높을 수록 CPU의 성능은 일반적으로 좋아진다.

> 클럭 속도는 일정하지 않다!
>
> CPU는 기본 클럭 속도(Base)와 최대 클럭 속도(Max)로 나뉘어 있듯, 일정한 속도를 유지하기보단, 고성능을 요하는 순간에 순간적으로 속도를 높이고, 그렇지 않을 때는 유연하게 조정합니다.
{: prompt-tip }

## 코어와 멀티코어

클럭 속도외에 CPU의 성능을 높이는 방법은 CPU의 코어와 스레드 수를 늘리는 방법이 있습니다.

이전 CPU는 단일 코어로, 명령어를 실행하는 하나의 부품이였던 반면, 최근 멀티코어의 등장으로, CPU 내에 명령어를 실행하는 부품을 여러개 만들 수 있게 되었습니다.

여기서 **코어**는 이전의 CPU의 정의였던 “명령어를 실행하는 부품”입니다.

## 스레드와 멀티스레드

스레드의 사전적 의미는 “실행 흐름의 단위” 입니다. 

**스레드 = 하드웨어적 스레드 + 소프트웨어적 스레드**

### 하드웨어적 스레드(논리 프로세서)

“하나의 코어가 동시에 처리하는 명령어 단위”를 의미합니다.

지금까지 배운 CPU는 1코어 1스레드 CPU였습니다.

하지만, 만약 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있습니다.

ex) 2코어 4스레드 CPU라면, 한 번에 네 개의 명령어를 처리할 수 있습니다.

이처럼 하나의 코어로 여러 명렁어를 동시에 처리하는 CPU를 **멀티 스레드 프로세서**라 합니다.

### 소프트웨어적 스레드

“하나의 프로그램에서 독립적으로 실행되는 단위”

하나의 프로그램이 실행되는 과정에서 한 부분만 실행될 수도 있지만,

프로그램의 여러 부분이 동시에 실행될 수도 있습니다.

ex) 워드 프로세서 프로그램을 개발한다면, 

1. 입력받은 내용을 화면에 보여 주는 기능
2. 입력한 내용이 맞춤법에 맞는지 검사하는 기능
3. 입력한 내용을 수시로 저장하는 기능

### 멀티스레드 프로세서

**멀티스레드 프로세서에서 가장 큰 핵심은 레지스터**

하나의 코어로 여러 명령어를 동시에 처리하려면, 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 가지고 있어야 합니다.

### 요약

코어 : 명령어를 실행할 수 있는 “하드웨어 부품”

스레드 : “명령어를 실행하는 단위”

멀티코어 프로세서 : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 2개 이상 있는 CPU

멀티스레드 포러세서 : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

# 5-2 명령어 병렬 처리 기법

키워드 : 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리 기법

---

명령어를 빠르고 효율적으로 처리하기 위해 CPU를 작동시키는 병렬 처리 기법에 대해 학습합니다.

빠른 CPU를 만들기 위해 높은 클럭 속도, 멀티코어와 멀티스레드를 지원하는 것도 중요하지만, 쉬지 않고 작동하게 만드는 것도 중요합니다.

→ **명령어 병렬 처리 기법(ILP; Instruction-Level Parallelism) !**

→ **대표적인 방법 = 명령어 파이프라이닝 ,슈퍼스칼라, 비순차적 명령어 처리**

## 명령어 파이프라이닝

명령어 처리 과정을 클럭 단위로 나눠 보면

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

> 전공서에 따라 명령어 인출 → 명령어 실행으로 나누기도 하고,
> 
> 인출 → 해석 → 실행 → 메모리 접근 → 결과 저장으로 나누기도 합니다.
{: .prompt-info }

중요한 점은 **같은 단계가 겹치지만 않는다면** CPU는 **각 단계를 동시에 실행할 수 있습니다.**

모든 명령어를 순차적으로 처리하는 것보다, 명령어 파이프라이닝을 이용한다면 훨씬 효율적으로 작동합니다.

![image.png](/assets/img/hongong/501.png)

하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있습니다.

- **파이프라인 위험(Pipeline Hazard)**

→ 데이터 위험

: 명령어 간 “데이터 의존성”에 의해 발생. 이전 명령의 데이터가 필요한 경우

→ 제어 위험

: 분기 등으로 인한 “프로그램 카운터의 갑작스러운 변화”에 의해 발생

→ 구조적 위험(자원 위험)

: 서로 다른 명령어가 동시에 ALU, 레지스터와 같은 부품을 사용하려 할 때

## 슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현 가능하지만, 오늘날 대부분의 CPU는 여러 개의 파이프라인을 이용합니다.

이처럼 여러 개의 명령어 파이프라인을 포함한 구조를 “슈퍼스칼라”라 합니다.

## 비순차적 명령어 처리(Out-of-order Execution)

오늘날의 대부분의 CPU가 차용하는 기법

비순차적으로 동작! “합법적인 새치기”

파이프라이닝, 슈퍼스칼라 기법은 모두 명령어의 순차적인 처리를 상정한 방법.

하지만, 이로 인해 pipeline hazard와 같은 상황에서 명령어가 곧바로 처리되지 않는 문제 발생 가능!

- 예시

![image.png](/assets/img/hongong/502.png)

- OoOE 기법 적용 시

![image.png](/assets/img/hongong/503.png)

# 5-3 CICS와 RISC

키워드 : ISA CISC RISC

CPU의 언어인 ISA란 무엇인지, 현대 CPU의 설계 방식인 CICS와 RISC에 대해 학습

---

파이프라이닝과 슈퍼스칼라를 사용하기 위해선, 명령어가 파이프라이닝 하기 쉽게 생겨야 함

→ 명령어가 어떻게 설계되어야 파이프라이닝 하기 쉬운 명령어인지 알기 위해 ISA를 배우고, CISC와 RISC에 관해 학습

## 명령어 집합(Instruction Set) or ISA

혹은 명령어 집합 구조(Instrunction Set Architecture : **ISA**)

ISA에는 x86, ARM등이 있으며, 이들은 서로 다른 설계를 갖기에 서로의 명령어를 이해할 수 없음.

→ 명령어가 달라지면 어셈블리어도 다름 

→ 똑같은 소스코드여도 컴파일 시 어셈블리어는 다름

병렬적 명령어 처리 기법(명령어 파이프라이닝, 슈퍼 스칼라 등)을 적용하기 좋은 ISA란?

## CISC (Complex Instruction Set Computer)

→ x86, x86-64는 대표적인 CISC기반 ISA

CISC는 다양하고 강력한 기능의 명령어 집합을 사용하기에, 명령어의 형태와 크기가 다양한

**가변 길이 명령어**를 활용

또한, 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식도 있음.

- 장점 : ARM보다 적은 명령어로 같은 동작을 할 수 있기에, 메모리 절약에 좋음.
- **단점 : 워낙 복잡하고 다양해 명령어의 크기와 실행되기까지의 시간이 일정하지 않음**

→ 복잡한 명령어는 하나를 실행하는 데에 여러 클럭 주기를 필요로 함

→ 명령어 파이프라인 구현에 큰 걸림돌

<aside>
💡

요약

CISC는 복잡하고 다양한 기능을 제공하기에 적은 수의 명령어로 프로그램 동작 가능!

이로 인해 메모리 절약이 가능하지만, 명령어의 규격화가 어려워 파이프라이닝 Hard.

그리고 대다수의 복잡한 명령어는 사용 빈도가 낮음.

→ CISC 기반 CPU는 성장에 한계가 있음.

</aside>

## RISC (Reduced Insturction Set Computer)

→ ARM은 대표적 RISC 기반 ISA

CISC가 준 교훈 2가지

1. 빠른 처리를 위해 명령어 파이프라인을 잘 활용해야 함. 이를 위해선 “명령어 길이와 수행 시간이 짧고 규격화”되어야 함.
2. 어차피 자주 쓰이는 명령어만 사용함. 복잡한 기능을 지원하는 명령어보단 “자주 쓰이는 기본적인 명령어를 작고 빠르게 만들기”

**→ RISC 등장!**

CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외! 즉, **고정 길이 명령어**

그리고, **메모리에 직접 접근하는 명령어를 Load, Store 두 개로 제한**할 만큼 메모리 접근을 단순화하고 최소화함!

**대신, 레지스터를 적극 활용!**

| CISC                               | RISC                               |
| ---------------------------------- | ---------------------------------- |
| 복잡하고 다양한 명령어             | 단순하고 적은 명령어               |
| 가변 길이 명령어                   | 고정 길이 명령어                   |
| 다양한 주소 지정 방식              | 적은 주소 지정 방식                |
| 프로그램을 이루는 명령어 수가 적음 | 프로그램을 이루는 명령어 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행       | 1클럭 내외로 명령어 수행           |
| 파이프라이닝하기 어려움            | 파이프라이닝하기 쉬움              |

---
---
---

> 위 내용은 한빛미디어의 "혼자 공부하는 컴퓨터 구조+운영체제" 교재를 학습하고, 정리한 글입니다.
{: .prompt-tip }
