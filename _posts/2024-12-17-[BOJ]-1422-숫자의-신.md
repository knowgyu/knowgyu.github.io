---
title: "[BOJ] 1422 숫자의 신"
author: knowgyu
description: " "
date: 2024-12-17 05:12:44 +0900
math: true
categories: [Computer Science, Problem Solving]
tags: [Algorithm, Problem Solving, BOJ]
---

---

> **문제 링크**: [백준 1422번](https://www.acmicpc.net/problem/1422)  
{: .prompt-tip }

## 문제 요약

주어진 \( K \)개의 숫자를 적어도 한 번씩 사용하고, 총 \( N \)개의 숫자를 뽑아 연결해서 만들 수 있는 **가장 큰 수**를 구하는 문제입니다.  
같은 숫자를 여러 번 사용할 수 있지만 **적어도 한 번은 모든 숫자를 사용해야** 합니다.

---

## 문제 풀이 아이디어

이 문제는 **가장 큰 수를 만들기 위해 그리디 알고리즘**을 사용해야 합니다.

하지만, 단순히 그냥 가장 큰 숫자를 선택하는 것이 아닌 상황을 고려하며 큰 수를 만들어야 합니다.

> 이전에 많은 문제들을 풀며 유사한 문제를 풀어봤기에 그나마 쉽게 풀 수 있었으나, 만약 처음으로 이런 문제를 마주했다면 꽤 어려웠을 것이라 생각됩니다.


### 핵심 아이디어

1. **숫자의 연결 순서를 정렬**:
   - 숫자 \( a \)와 \( b \)를 **문자열로 연결**했을 때:  
     - \( a + b > b + a \)가 성립하면 \( a \)를 \( b \) 앞에 배치합니다.  
     - 이렇게 정렬하면 **가장 큰 수**를 만들 수 있습니다.  

  > 이것만을 이용해 풀 수 있는 플레티넘5 정렬 문제도 있습니다.
  {: .highlight }

2. **N > K인 경우**:
   - 모든 숫자는 적어도 한 번 사용해야 합니다.  
   - 나머지 \( N - K \)개의 숫자는 **가장 큰 숫자**를 여러 번 반복해서 사용하면 됩니다.  
     - 가장 큰 숫자는 문자열 길이와 값을 비교해서 찾습니다.

3. **두 가지 정렬 조건**:
   - 첫 번째 정렬(`cmp1`): 가장 큰 숫자를 찾기 위해 **길이가 긴 숫자** 또는 **숫자값이 큰 경우**를 우선합니다.  
   - 두 번째 정렬(`cmp2`): 숫자를 연결했을 때 \( a + b > b + a \) 조건을 기반으로 정렬합니다.

---

## 정답 코드

```cpp
#include<bits/stdc++.h>
using namespace std;

// 가장 큰 숫자를 만들기 위한 첫 번째 비교 함수
bool cmp1(const string& a, const string& b) {
    if (a.length() == b.length()) return a + b > b + a; // 문자열 연결 비교
    return a.length() > b.length(); // 길이가 긴 숫자를 우선
}

// 숫자를 연결했을 때 더 큰 값을 만드는 두 번째 비교 함수
bool cmp2(const string& a, const string& b) {
    return a + b > b + a; // 연결 순서로 비교
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int K, N;
    cin >> K >> N; // K: 입력 숫자 개수, N: 최종 숫자 개수
    int n = N;

    vector<string> arr(K);
    for (int i = 0; i < K; i++) {
        cin >> arr[i];
    }

    // N이 K보다 큰 경우, 가장 큰 숫자를 반복해서 사용해야 함
    if (N > K) {
        sort(arr.begin(), arr.end(), cmp1); // 가장 큰 숫자를 찾기 위해 정렬
        while (N > K) { 
            arr.push_back(arr[0]); // 가장 큰 숫자를 반복 삽입
            --N;
        }
    }

    // 숫자를 연결했을 때 가장 큰 값을 만들기 위해 정렬
    sort(arr.begin(), arr.end(), cmp2);

    // 결과 출력
    for (int i = 0; i < n; i++) {
        cout << arr[i];
    }

    return 0;
}
```

---

## 코드 설명

1. **첫 번째 정렬 함수 (`cmp1`)**:  
   - 가장 큰 숫자를 찾기 위해 문자열의 길이와 연결 결과를 비교합니다.  
   - 가장 긴 숫자 또는 연결 시 더 큰 결과를 만드는 숫자를 우선합니다.

2. **N > K인 경우**:  
   - 가장 큰 숫자를 반복해서 사용해야 하므로 첫 번째 정렬로 가장 큰 숫자를 찾고, **남은 자리를 채웁니다**.

3. **두 번째 정렬 함수 (`cmp2`)**:  
   - 숫자를 연결했을 때 \( a + b > b + a \)를 만족하도록 정렬합니다.  
   - 이를 통해 숫자를 이어 붙였을 때 최종 결과가 가장 크게 됩니다.

---

## 시간 복잡도 분석

- **정렬 연산**: \( O(K \log K) \)  
- **N > K 처리**: 가장 큰 숫자를 반복 추가하는데 \( O(N - K) \)  
- **전체 시간 복잡도**: \( O(K \log K + N) \)  
  \( K \)와 \( N \)은 최대 \( 50 \)이므로 충분히 동작합니다.
