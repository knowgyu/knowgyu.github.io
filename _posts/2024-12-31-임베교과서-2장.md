---
title: "[임베교과서] 2장 마이크로컴퓨터 하드웨어"
author: knowgyu
description: " "
date: 2024-12-16 15:00:00 +0900
categories: [Embedded System, 임베디드 엔지니어 교과서]
tags: [Embedded System, 임베디드 엔지니어 교과서]
---

임베디드 시스템은 목적에 맞게 **하드웨어**와 **소프트웨어**가 **기기 내부에 내장**되어 동작하는 구조입니다.  
이를 통해 특정 기능에 최적화된 **전용 동작**을 수행하며, 일반적인 PC나 서버와 달리 **운영 중 기능이 크게 바뀌지 않는** 경우가 많습니다.

이번 장에서는 임베디드 시스템을 구성하는 **마이크로컴퓨터**(CPU·메모리·주변장치)의 핵심 부품들과, 이들이 **어떻게 상호 연결**되는지 간단히 살펴보겠습니다.

---

## 임베디드 시스템의 구성

**임베디드 시스템**은 크게 **하드웨어**와 **소프트웨어**로 나뉩니다.  
- 하드웨어: **CPU(연산 장치)**, **메모리(ROM, RAM)**, **주변장치(Peripheral)**  
- 소프트웨어: CPU가 실행할 **프로그램(펌웨어, OS 등)**

일반 PC와 달리, 임베디드 시스템은 **정해진 기능**을 수행하기 위해 설계됩니다.  
운영 중에 새로운 기능이 추가되거나, 목적이 극단적으로 바뀌는 일은 상대적으로 드뭅니다.

---

## 임베디드 마이크로컴퓨터의 구성

### 하드웨어의 종류

1. **CPU** (Central Processing Unit)  
   - 연산을 담당하는 **중앙 처리 장치**입니다.  
   - 마이크로컴퓨터(MCU)의 두뇌 역할을 하며, 여러 비트 폭(4비트 ~ 64비트 등)에 따라 처리 성능이 달라집니다.

2. **메모리**  
   - **ROM**: 프로그램이나 데이터를 저장해 두고 **읽기만** 하는 영역  
   - **RAM**: 프로그램이 동작할 때 **일시적으로** 데이터를 저장하는 영역

3. **주변장치(Peripheral)**  
   - 입출력을 담당하는 각종 부품들  
   - 예: 타이머, UART, I2C, SPI, DMA 컨트롤러 등

> PC에서는 고성능 하드웨어가 많지만, 임베디드 하드웨어는 **정해진 목적**에 맞춰 **필요 최소한의 구성**을 갖추는 경우가 많습니다.  
{: .prompt-tip }

---

### CPU와 마이크로컴퓨터

CPU는 **계산**에 필요한 여러 부품(연산 장치, 레지스터, 제어 장치 등)을 **하나의 칩**에 넣은 것입니다.  
- **Intel 4004**(4비트)가 세계 최초의 상업용 마이크로컴퓨터로 알려져 있으며, 이후 성능이 꾸준히 발전해 왔습니다.  
- 오늘날 마이크로컴퓨터(또는 마이크로컨트롤러)는 CPU뿐 아니라, **주변장치**(타이머, UART, I2C, SPI 등)를 **하나의 칩**에 내장해 기능을 확장합니다.

> **CPU가 두뇌라면**, 주변장치는 **눈, 귀, 손**처럼 외부 정보를 받아들이고, 필요한 동작을 실제로 수행하는 역할을 담당합니다.  
{: .prompt-info }

#### 버스(bus)

CPU와 주변장치는 **버스**라고 부르는 신호선을 통해 연결됩니다.  
- CPU의 명령은 버스를 통해 주변장치로 전달되고,  
- 주변장치의 출력은 다시 버스를 통해 CPU로 전송됩니다.

---

### 메모리

임베디드 시스템이 **복잡한 기능**을 수행하기 위해서는 **CPU**가 **프로그램**을 실행해야 합니다.  
- 프로그램(기계어 명령)과 함께, 실행 중 발생하는 **데이터**를 저장할 공간이 필요합니다.  
- 이를 위해 **ROM**과 **RAM**을 활용합니다.

#### ROM (Read Only Memory)

- **읽기 전용 비휘발성** 메모리  
- 프로그램(기계어 명령)은 주소(Address)에 따라 저장돼 있으며, CPU는 필요한 주소를 읽어 **명령**을 가져갑니다.

#### RAM (Random Access Memory)

- CPU가 프로그램 실행 중 **임시 저장** 공간으로 사용하는 **휘발성** 메모리  
- 전원이 꺼지면 데이터가 지워지므로, 오직 **실행 시**에만 활용됩니다.

---

### 메모리의 종류

위에서 메모리는 크게 ROM과 RAM이 있다했는데, 여기서도 추가적인 분류가 있습니다.  

1. **ROM**  
   - **마스크 ROM**: 제조 공정에서 데이터를 써 넣으면 **변경 불가**  
   - **프로그램 가능 ROM(Programmable ROM)**: 데이터를 기록한 뒤 **수정 가능**

2. **RAM**  
   - **DRAM (Dynamic RAM)**: 주기적으로 **리프레시**가 필요하지만, 대용량 구성이 쉬움  
   - **SRAM (Static RAM)**: 리프레시가 필요 없어 **고속 접근**이 가능하지만, 제조 단가가 높아 **캐시 메모리** 등에 주로 사용

> **SRAM이 DRAM보다 빠른 이유**  
> DRAM은 메모리 셀(1개의 트랜지스터 + 1개의 캐패시터)을 주기적으로 읽고 쓰는 **리프레시** 작업이 필요합니다. 반면, SRAM은 **6개의 트랜지스터**로 구성되어 리프레시가 필요 없으므로 속도가 빠릅니다. 다만, 구성 트랜지스터 수가 많아 대용량 구현이 어렵고 비용이 높은 단점이 있습니다.  
> (즉, 캐패시터의 유무라는 구조적 차이로 인해 리프레시의 동작이 결정됩니다)  
{: .prompt-info }

---

### 버스의 구성

임베디드 시스템에서 CPU가 메모리나 주변장치와 **데이터를 주고받는** 통로를 **버스**라고 합니다.  
버스는 성능과 목적에 따라 **메인 버스(Main Bus)**와 **로컬 버스(Local Bus)**로 나뉘어 동작하는 경우가 많습니다.

1. **메인 버스**  
   - **고속 동작**이 필요한 메모리나 주변장치가 연결되는 버스  
   - **주소 버스(Address Bus)**: 접근하려는 **메모리 주소**나 **주변장치** 위치를 지정  
   - **데이터 버스(Data Bus)**: 읽거나 써야 할 **데이터**가 오가는 경로  
   - **컨트롤 버스(Control Bus)**: 메모리, 주변장치를 **제어**하기 위한 각종 신호
   
2. **로컬 버스**  
   - **저속**으로 동작하는 주변장치가 연결되는 버스  
   - **브릿지(Bridge)**: 메인 버스와 로컬 버스 간 **속도 차**를 조정하는 하드웨어 컨트롤러  

> **브릿지**는 고속 메인 버스와 저속 로컬 버스를 연결해 주며, 통신 타이밍을 맞춰주는 역할을 수행합니다.  
{: .prompt-info }

---

### 주변장치 (Peripheral)

주변장치는 **임베디드 시스템의 용도**에 따라 다양하게 구성됩니다.  
아래는 대표적인 주변장치들입니다.

#### DMA(Direct Memory Access) 컨트롤러

- CPU 개입 없이 **주변장치**와 **메모리** 간에 직접 데이터 전송이 가능하도록 하는 장치  
- 대량 데이터 전송 시 **CPU 부하**를 줄이는 데 유용  
- 버스 사용 충돌을 막기 위해 **버스 아비터(Bus Arbiter)**가 중재 역할을 수행

> DMA 설정(주소, 전송 크기)을 잘못할 경우 큰 사고가 발생할 수 있기에, 신중하게 설정해야 합니다.  
{: .prompt-warning }

#### 타이머

- 일정 시간이 흐른 뒤 **인터럽트**를 걸어, CPU가 필요한 작업을 **주기적**으로 수행하게 만듦  
- 임베디드 시스템에서 **주기적 관측**(센서 감시, 데이터 출력 등)에 필수적

#### RTC(Real Time Clock)

- 실제 **날짜와 시간**을 카운팅하는 주변장치  
- CPU 전원이 꺼진 상태에서도 **백업 배터리**를 통해 시간을 유지함

#### GPIO(General Purpose Input/Output)

- **범용 입출력 포트**  
- 간단한 신호를 주고받거나, 외부 페리퍼럴에서 발생하는 **인터럽트** 신호를 처리하는 등 여러 용도로 사용

---

### 로컬 버스와 주변 통신

**저속 주변장치**들은 보통 **로컬 버스**에 접속하며, **브릿지**를 통해 메인 버스와 연결됩니다.

#### UART (Universal Asynchronous Receiver/Transmitter)

- **병렬 신호**(CPU 내부 데이터)와 **직렬 신호**(Tx/Rx) 간 상호 변환을 담당  
- 임베디드 시스템에서 **시리얼 콘솔**(디버깅, 메시지 출력)로 자주 쓰임

> **예시**로, 우체국 서비스를 생각해 보겠습니다.  
>   **CPU**가 편지(병렬 데이터)를 우체국(UART)에 맡기면, 우체국이 편지를 **한 줄(직렬)로** 정리해 전송(Tx)하고,  
>   반대로 **다른 곳**에서 오는 편지(직렬 데이터)를 모아서, CPU가 읽기 쉬운 형태(병렬)로 바꿔주는 작업을 합니다.  
{: .prompt-tip }

#### I2C (Inter-Integrated Circuit)

- **동기식 직렬 통신** 방식  
- **SCL**(시리얼 클럭)과 양방향 **SDA**(시리얼 데이터) **두개의 신호선** 사용  
- **마스터-슬레이브 구조**로, 마스터가 각 **슬레이브의 주소를 지정**해 통신  
- 센서(가속도, 터치 등) 연결에 자주 사용

#### SPI (Serial Peripheral Interface)

- **동기식 직렬 통신** 방식  
- **SCK**(시리얼 클럭), 단방향 **SDI**(시리얼 데이터 인), **SDO**(시리얼 데이터 아웃) **3개 신호선** 사용  
- 슬레이브 장치 선택 시 **Slave Select(SS)** 제어 신호 활용  
- 데이터 포맷이 단순하고 고속 전송이 가능하나, I2C보다 **배선이 많음**  
- 플래시 메모리나 CPU 간 통신 등에 자주 쓰임

> UART, I2C, SPI 모두 **GND(그라운드)** 선이 필요합니다. GND는 전위를 만들기 위해 사용되는 신호인데,
> 각 장치 사이에 GND가 다르면 신호를 제대로 인식하지 못하는 상황이 발생할 수 있기에 GND를 사용하는 것이 일반적입니다.  
{: .prompt-info }

#### (참고) I2C와 SPI의 슬레이브 지정 방식
위에서 I2C는 슬레이브의 주소를 지정해서, SPI는 SS 제어 신호를 활용한다고 했습니다.  
이 부분에 대해 공부할 때 명확하지 않았어서, 예시 상황을 떠올려 보겠습니다.  

##### I2C 예시 상황
**MCU(마스터)** 와 **온도 센서**(0x48), **가속도 센서**(0x1D)가 한 I2C 버스에 연결  
I2C는 SCL, SDA 단 두 신호선만 사용  
각 슬레이브 센서는 고유한 주소를 가짐  

MCU가 통신을 시작하면 SCL, SDA 라인을 통해 "**0x48**을 불러서, **읽기** 작업을 할것이다!" 라는 신호를 보냅니다.  
-> 버스에 있는 모든 센서가 이 주소를 듣고, **온도 센서**만 자신의 주소가 맞기에, "**ACK**"라 응답하고, 나머지는 대기합니다.  

MCU와 온도 센서 간 데이터가 SDA 선을 통해 주고받습니다.  
MCU가 "Stop" 신호를 보내면 통신을 종료합니다.  

> 위와 같이, I2C는 **주소**를 통해 슬레이브를 가려냅니다!

##### SPI 예시 상황
**MCU(마스터)**와 **SPI 플래시 메모리**, **SPI LCD**가 한 SPI 버스에 연결  
SPI는 SCK, MOSI(SDI), MISO(SDO), SS(또는 CS) 신호선을 사용  
각 슬레이브는 **별도의 SS 핀**으로 활성화 여부를 구분  

MCU가 통신을 시작하려하면, 우선 "**플래시 메모리**"의 SS를 "**Low**"로 만들어 **활성화** 합니다.  
-> 동시에, LCD 등 다른 슬레이브의 SS는 High로 둡니다.  

MCU와 플래시 메모리 간에 **MOSI**와 **MISO**를 통해 데이터를 직렬로 주고 받으며,  
**SCK**로 시그널의 타이밍(클럭)을 동기화 합니다.  

MCU가 통신을 마치면, 플래시 메모리의 **SS**를 다시 High로 되돌려 **비활성화** 시킵니다.

> 위와 같이, SPI는 **슬레이브 셀렉트**핀을 통해 통신할 슬레이브를 **직접** 지정합니다.  

---

### 주변장치의 제어 방식

대부분의 주변장치는 **레지스터(Register)**라는 특수 메모리를 통해 **CPU가 읽고/쓰는 방식**으로 제어됩니다.

1. **Memory Mapped I/O**  
   - **ROM, RAM과 동일한 주소 공간**을 사용  
   - 주변장치에 접근할 때 **특정 주소**를 읽고 쓰면, 레지스터로 매핑된 주변장치를 제어하는 방식  
2. **I/O Mapped I/O**  
   - **ROM, RAM과는 별도의 주소 공간** 및 **전용 명령**을 사용  
   - CPU 아키텍처에 따라 구현 방식이 다르므로 **데이터시트**를 확인해야 합니다.

---

## CPU란?

CPU는 **Central Processing Unit**의 약자이며, **ROM**에서 실행할 명령을 읽고 해석한 뒤 수행합니다. 그 결과는 **RAM** 등에 저장됩니다.

CPU 내부는 크게 **프로그램 카운터(PC)**, **디코더**, **시스템 레지스터**, **범용 레지스터**, **ALU**(Arithmetic and Logic Unit)로 구성됩니다.

---

### 프로그램 카운터(PC)

- **PC**는 ROM 안의 프로그램 중 **어느 명령을 실행할지**를 관리하는 하드웨어입니다.  
- 프로그램은 기계어 형태로 ROM의 특정 주소(번지)에 나누어 저장되어 있습니다.  
- PC는 **다음에 실행할 명령의 주소**를 CPU에 전달함으로써, CPU가 순서대로 명령을 가져오도록 돕습니다.

### 디코더

- **디코더**는 CPU가 읽어 들인 명령을 **해석**하는 하드웨어입니다.  
- 명령에 따라 **어떤 연산**을 할지(ALU 사용, 데이터 이동 등) 정해 CPU 내부에서 실행이 이뤄집니다.

### ALU (Arithmetic and Logic Unit)

- **ALU**는 덧셈, 뺄셈, AND, OR, NOT 등 **논리 연산**을 수행합니다.  
- 연산 결과는 **범용 레지스터**나 **시스템 레지스터**에 저장됩니다.

### 범용 레지스터

- CPU 내부에 있는 **고속 메모리**로, 작은 용량이지만 **데이터를 임시로 저장**하기에 유용합니다.  
- ALU 연산 결과나 데이터 이동 시 **중간 저장소**로 자주 쓰입니다.

### 시스템 레지스터

- CPU가 명령을 실행할 때 사용하는 다양한 **특수 레지스터**입니다.  
  - 예: **명령 레지스터(명령 저장)**, **주소 레지스터(번지 관리)**, **상태 레지스터(플래그 관리)** 등  
- **상태 레지스터**는 ALU 연산 결과나 인터럽트 상태를 **비트 단위**로 기록합니다.

| 비트  | 이름  | 용도                                               |
| :---: | :---: | :------------------------------------------------- |
|   0   |   C   | Carry (ALU 연산에서 오버플로 발생 여부 관리)       |
|   1   |   Z   | Zero (연산 결과가 0인지 여부 관리)                 |
|   2   |   N   | Negative (덧셈·뺄셈 종류·부호 상태를 관리)         |
|   4   |   S   | Sign (연산 결과가 음수인지 양수인지 확인)          |
|   5   |   H   | Half Carry (연산 과정 중 하프 캐리 발생 여부 관리) |
|   7   |   I   | Interrupt (인터럽트를 허용할지 여부 관리)          |

---

### CPU의 명령 실행

CPU가 명령을 실행하는 과정은 아키텍처마다 조금씩 다를 수 있지만, 기본적으로는 **4단계**입니다:

1. **명령 패치 사이클**  
   - PC가 가리키는 **ROM 주소**에서 기계어 명령을 가져옵니다.
2. **명령 디코드 사이클**  
   - 가져온 명령을 **디코더**가 해석하여, 어떤 연산을 실행할지 결정합니다.
3. **실행 사이클**  
   - ALU 등을 통해 **실제 연산**이나 데이터 이동이 이루어집니다.
4. **라이트 백 사이클**  
   - 연산 결과를 **범용 레지스터**나 **메모리** 등에 기록합니다.

이 과정을 거쳐 한 명령의 실행이 완료됩니다.

#### CPU의 명령 종류

CPU가 처리하는 명령은 크게 **세 가지** 범주로 나눌 수 있습니다.

1. **CPU ↔ 메모리** 사이의 데이터 교환  
2. **CPU ↔ 주변장치** 사이의 데이터 교환  
3. **CPU 내부에서만** 수행되는 명령 (레지스터 간 이동 등)

데이터 연산은 주로 **ALU**에서 이뤄지며, 그 결과는 **범용 레지스터**를 통해 보관하거나 **메모리**로 옮깁니다.

---

### 인터럽트

**인터럽트**는 주변장치 등이 CPU에게 “이 작업을 처리해 달라”고 **요청**하는 신호입니다.  
CPU가 인터럽트 신호를 받으면, **인터럽트 벡터 테이블**에 기록된 **특정 루틴(ISR)**으로 실행 흐름을 바꿉니다.  
이 루틴이 끝나면 원래 실행 중이던 위치로 되돌아가 작업을 이어갑니다.

인터럽트는 크게  
- **타이머 인터럽트**: CPU 내부 타이머에서 발생  
- **외부 인터럽트**: 주변장치 등 외부 하드웨어에서 발생  
등으로 나뉩니다.

---

#### 인터럽트 종류와 인터럽트 벡터

- 임베디드 환경에서는 여러 인터럽트가 발생할 수 있으므로, 각 인터럽트 신호(타이머, UART Rx, GPIO 등)에 대응하는 **루틴의 시작 주소**를 **인터럽트 벡터 테이블**에 미리 등록합니다.  
- CPU가 특정 인터럽트를 감지하면, **해당 인터럽트 번호**에 맞는 **프로그램 시작 주소**를 찾아가 루틴을 실행합니다.  

#### 인터럽트의 우선순위

- 여러 인터럽트가 **동시에** 발생할 때는 **우선순위(Priority)**를 따져 처리 순서를 결정합니다.  
- CPU 내부 레지스터 등을 이용해 **긴급한 인터럽트(안전·보호 장치 등)는 우선순위 높게**, 덜 중요한 인터럽트는 낮게 설정하는 식입니다.

---

> 위 내용은 **제이펍**의 "**임베디드 엔지니어 교과서**"를 읽고 공부한 것을 정리한 글입니다.  
> 저자명 : 와타나베 노보루, 마키노 신지 / 역자명 : 정인식
{: .prompt-tip }
