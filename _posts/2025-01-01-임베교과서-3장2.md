---
title: "[임베교과서] 3장 임베디드 소프트웨어 (2)"
author: knowgyu
description: " "
date: 2024-12-23 12:00:00 +0900
categories: [Embedded System, 임베디드 엔지니어 교과서]
tags: [Embedded System, 임베디드 엔지니어 교과서]
---

## 어셈블리 언어로부터 알 수 있는 것

이 전 페이지에서 **빌드 흐름**을 알아보았습니다. 이제는 **중간 과정**에서 생성된 **어셈블리어**를 살펴보겠습니다.

앞서 사용했던 “Hello World” 프로그램을 조금 변경해 예시로 들어 보겠습니다.

**main2.c**
```c
#include <stdio.h>

char str[]="Hello World";
int data;

int func(int x,int y){
    return x+y;
}

int main(){
    data = func(2018,2019);
    printf("%s:%x\n", str, data);
    return 0;
}
```

위 코드를 빌드할 때는 최적화 옵션을 없애기 위해 `-Os` 대신 `-O0`를 사용합니다.

```bash
avr-gcc -O0 -Wall -mmcu=atmega328p main2.c -o main2.elf
```

생성된 ELF 파일은 바이너리 파일 형태이므로, **`avr-objdump`** 명령어를 이용해 텍스트 형태로 확인해 봅시다.

```bash
avr-objdump -S main2.elf > main2.s
```

**main2.s** 파일에는 실제 어셈블리 코드가 담겨 있습니다.  
![alt text](/assets/img/ebtb/eb33.png)

---

### 스타트업 루틴

`main2.s`를 살펴보면 `000000d4 <main>:` 부분이 있습니다.  
이는 **main 함수의 어셈블리 변환 코드**이며, `000000d4`는 **16진수 주소**를 의미합니다.

그런데 **main 함수 이전**에도 여러 설정 코드가 있는데, 이를 **스타트업 루틴(start-up routine)**이라고 부릅니다.  
- 하드웨어 초기 설정  
- 프로그램 동작을 위한 **메모리 초기화**(전역변수, 스택 영역 등)  
- 기타 **소프트웨어 환경** 구성

이 과정을 마친 뒤 **main 함수**가 호출되어 C 코드가 동작하기 시작합니다.

---

### main 함수가 호출될 때까지 흐름 추적

1. **전원 ON & 리셋 신호**  
   - 임베디드 기기에 **전원이 켜지면**, CPU가 **리셋 신호**를 받아 **0번지**부터 명령을 실행합니다.

2. **인터럽트 벡터 설정, 스택 초기화**  
   - **인터럽트 벡터 테이블** 작성, **스택 영역** 설정, **데이터 영역** 초기화 등이 순차적으로 이루어집니다.

3. **main 함수 진입**  
   - 초기화가 끝나면 **main 함수** 주소로 점프해, 우리가 작성한 C 코드가 본격 실행됩니다.

> **Tip**: 이런 부트 과정(Reset → 초기화 → main)은 아키텍처와 루틴 구현 방식에 따라 조금씩 달라집니다.  
> 아래 깃허브 레포에 전체 코드를 확인할 수 있습니다.  
> [링크](https://github.com/knowgyu/embedded-textbook)
{: .prompt-tip }

---

### 메모리 맵

프로그램이 어느 영역(ROM or RAM)에 배치되는지 나타낸 것을 **메모리 맵**이라 부릅니다.  
이는 보통 **CPU 및 시스템 설계**에 의해 정해지며, 소프트웨어에서 임의로 바꿀 수 없는 경우가 많습니다.

- **코드 영역**: 보통 **ROM**(플래시)에 위치, 여기엔 `.text` 세션(C 함수, 명령어)이 들어감  
- **데이터 영역**: 보통 **RAM**에 위치, 전역변수(.data), 초기화되지 않은 전역변수(.bss) 등이 포함

예를 들어, 아래 명령어로 ELF 헤더 정보를 확인할 수 있습니다.

```bash
avr-objdump -x -h main2.elf
```

```
main2.elf:     file format elf32-avr
architecture: avr:5, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000

Program Header:
    LOAD off    0x00000094 vaddr 0x00000000 paddr 0x00000000 align 2**1
    ...

Sections:
Idx Name       Size      VMA       LMA       File off  Algn
 0  .data      00000014  00800100  000006f4  00000788  2**0
               CONTENTS, ALLOC, LOAD, DATA
 1  .text      000006f4  00000000  00000000  00000094  2**1
               CONTENTS, ALLOC, LOAD, READONLY, CODE
 2  .bss       00000008  00800114  00800114  0000079c  2**0
               ALLOC
 3  .comment   00000011  00000000  00000000  0000079c  2**0
               CONTENTS, READONLY
...
```

- `.text` → **프로그램 코드**(ROM)  
- `.data` → 초기값이 있는 전역변수(RAM에 복사)  
- `.bss` → 초기값이 없는 전역변수(RAM)  

---

## 임베디드 소프트웨어의 테스트 환경

빌드를 마친 뒤에는, 실제 임베디드 하드웨어에 **ROM**을 기록하고 동작을 확인합니다.  
하드웨어가 정상적으로 구동되는지 테스트해야 하며, 이를 위해 **특수 장비**가 쓰이기도 합니다.

---

### ICE (In-Circuit Emulator)

- **ICE**는 임베디드 시스템에 탑재된 CPU를 대신해 **동작**시켜 볼 수 있는 장비입니다.  
- 예: **JTAG ICE**, **Full ICE** 등  
- 또한, PC와 연결해 **JTAG 인터페이스**를 통해 디버깅하거나, **시리얼 포트**나 **오실로스코프**로 회로 파형을 관찰하기도 합니다.

> 이 부분에 대한 구체적인 사용 예시는 추후 별도 글에서 다룰 예정입니다.  
{: .prompt-info }

---

## 임베디드 시스템 프로그래밍에서의 C언어

임베디드 시스템은 **메모리나 처리 시간 제약**이 있을 가능성이 높아, **최적화**가 중요합니다.  
여기서, 컴파일러 설정에 주의해야 합니다.  

---

### 최적화 옵션의 장점과 단점

- **장점**: 제한된 메모리나 프로세싱 시간을 절약할 수 있어, 시스템 요구사항을 충족시키기 쉬워짐.  
- **단점**: 최적화 과정에서 **컴파일러가 코드를 재배치**하거나 **불필요하다고 판단**한 부분을 제거해, **의도치 않은 동작**이 일어날 수 있음.

---

### volatile 선언

주변장치 레지스터나 **하드웨어 상태**가 수시로 변경되는 값을 다룰 때는 **volatile**을 사용해야 합니다.  
- 예: `while (flag == 0);` 형태로 하드웨어에서 바뀌는 **flag**를 체크할 경우,  
- 컴파일러가 **“flag는 안 바뀐다”**고 판단해 캐싱해버릴 수 있음.  
- **volatile**로 선언하면 “**이 변수는 언제든 바뀔 수 있음**”임을 컴파일러에 알려, 올바른 값으로 매번 읽게 해줍니다.

> 위와 같이 주기적으로 상태를 점검하는 방식을 "폴링(Polling)"이라 합니다.  

---

### unsigned와 signed

하드웨어 레지스터를 읽고 쓰는 경우, **부호 없는 정수(unsigned)**로 처리하는 것이 일반적입니다.  
- 임베디드 시스템에서 레지스터의 상위 비트가 어떤 상태 플래그인지 모호해질 수 있으므로,  
- **음수**로 해석되지 않도록 **unsigned**를 적절히 사용해야 합니다.

---

### pragma

**pragma**는 컴파일러에게 특정 설정(메모리 배치 등)을 지시하는 기능입니다.  
- 예를 들어, 특정 구조체를 **패킹(packing)** 처리하거나,  
- 특정 코드/데이터를 **독자적인 메모리 섹션**에 배치하는 것도 가능합니다.  
- 단, **컴파일러에 의존**하므로, 호환성에 주의해야 합니다.

---

### 포인터와 배열

임베디드 CPU는 일반 PC보다 **처리 성능이나 메모리 용량이 작을** 가능성이 큽니다.  
- 따라서 **포인터 연산**, **배열 접근** 등도 효율적으로 써야 하고,  
- **컴파일러 최적화**와 함께 **코드 레벨 최적화**(메모리 접근 방식, 자료구조 선택 등)를 고민해야 합니다.

---

### 인터럽트 핸들러

**인터럽트 핸들러**는 인터럽트 처리에 등록하기 위해 작성된 프로그램입니다.  
- 일반 동작보다 **높은 우선순위**를 갖기 때문에, **처리 시간을 짧게** 유지하는 것이 좋습니다.  
- 인터럽트가 끝나야 원래 작업(main 루프 등)이 재개되므로, 길고 복잡한 인터럽트 루틴은 시스템 응답성을 떨어뜨릴 수 있습니다.

AVR 환경에서는 `<avr/interrupt.h>`에 정의된 **ISR** 매크로를 사용해, 특정 인터럽트 벡터에 함수를 등록합니다.

```c
#include <avr/io.h>
#include <avr/interrupt.h>

ISR(TIMER0_OVF_vect) {
    // 8비트 타이머0 오버플로 인터럽트 루틴
    // 필요한 최소한의 작업만 빠르게 처리
}
```

위처럼 **타이머0 오버플로** 인터럽트가 발생하면, CPU가 해당 ISR로 즉시 점프해 코드를 실행합니다.

---

> 위 내용은 **제이펍**의 "**임베디드 엔지니어 교과서**"를 읽고 공부한 것을 정리한 글입니다.  
> 저자명 : 와타나베 노보루, 마키노 신지 / 역자명 : 정인식
{: .prompt-tip }
