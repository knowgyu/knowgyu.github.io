---
title: "Git 튜토리얼 1"
author: knowgyu
description: " "
date: 2025-01-15 12:29:23 +0900
math: true
categories: [Computer Science, Git]
tags: [Git, 버전관리]
---

## 개요

이 글은 [Learn Git Branching](https://learngitbranching.js.org/?locale=ko) 튜토리얼을 참고하여 Git의 주요 개념과 기능들을 정리한 내용입니다.  

---

## Git 커밋

Git에서 **커밋**은 작업 디렉터리의 상태(변경 사항)를 저장소에 기록하는 순간입니다.  
실제로 Git은 디렉터리 내 모든 파일의 전체 스냅샷을 저장하는 것이 아니라, 파일들의 **변경 내역(Delta)** 만을 저장하여 효율적으로 버전을 관리합니다.  
커밋을 생성하면, 변경된 내용이 추적 가능하며 나중에 특정 시점으로 되돌리거나 비교할 수 있습니다.

```bash
git commit -m "커밋메시지"
```

---

## Git 브랜치

**브랜치**는 저장소 내의 특정 커밋을 가리키는 포인터(참조)입니다.  
- **핵심:** 브랜치는 실제 작업 내역을 복사하지 않고, 단지 어떤 커밋을 기준으로 작업을 진행할 것인지를 가리키기 때문에, 브랜치를 만드는 데 별도의 메모리나 디스크 공간이 크게 소모되지 않습니다.
- **권장:** “빨리 그리고 자주 브랜치를 만들어라!”  
  작업 단위를 작게 나누어 관리하면, 나중에 통합(merge)할 때 발생하는 충돌이나 문제를 줄일 수 있습니다.

기본 사용법:
- 브랜치 생성:  
  ```bash
  git branch [브랜치이름]
  ```
- 브랜치 이동:  
  ```bash
  git checkout [브랜치이름]
  ```
  
이 때, 브랜치는 하나의 커밋과 그 부모 커밋들을 포함하는 작업 내역의 연속처럼 보이지만, 실제로는 단순히 특정 커밋을 가리키는 레퍼런스입니다.

---

## Git 머지

**머지(Merge)**는 두 개 이상의 브랜치의 작업 내역을 하나로 합치는 과정입니다.  
머지를 수행하면, 두 부모의 작업 내역을 통합한 새로운 **병합 커밋(Merge Commit)** 이 생성됩니다.  
예를 들어, `bugFix` 브랜치에서 작업한 내용을 `main` 브랜치에 병합하려면:

```bash
git checkout main
git merge bugFix
```

이렇게 하면 `main` 브랜치에 `bugFix`의 작업 내역이 합쳐집니다.

---

## Git 리베이스

**리베이스(Rebase)**는 현재 브랜치의 커밋들을 다른 브랜치의 최신 커밋 뒤에 재적용하는 작업입니다.  
- 리베이스는 기존 커밋의 복사본을 만들어 새로운 베이스 위에 재적용하기 때문에, 커밋 로그가 한 줄로 깔끔하게 정리되는 효과가 있습니다.
- 저장소의 커밋 이력이 깨끗해지는 장점이 있으나, 공개된 히스토리에서 리베이스를 사용하면 협업 시 문제가 발생할 수 있으므로 주의해야 합니다.

사용 예:
```bash
git rebase [브랜치명]
```

예를 들어, `bugFix` 브랜치에서 작업한 커밋들을 `main` 브랜치의 최신 커밋 뒤에 붙이고 싶다면 `git rebase main`을 실행합니다.

---

## Git HEAD

**HEAD**는 현재 체크아웃되어 작업 중인 커밋을 가리킵니다.  
- 일반적으로는 브랜치(예: `bugFix` 또는 `main`)가 HEAD를 가리키지만, 특정 커밋 해시로 직접 체크아웃할 경우에는 고정된 과거 커밋을 가리키게 됩니다.
- 커밋을 생성하면 HEAD가 자동으로 최신 커밋을 가리키게 됩니다.

---

## 상대 참조

커밋 해시는 SHA1 알고리즘에 의해 생성되므로 매우 길고 복잡하지만, Git은 **상대 참조**를 통해 간단하게 표현할 수 있도록 지원합니다.
- `^`: 한 단계 부모 커밋을 가리킵니다.
- `~<숫자>`: 여러 단계 위의 부모 커밋을 가리킵니다.

예:
```bash
git checkout main^
git checkout main~1
```
이 둘은 동일하게 `main` 브랜치의 한 단계 이전 커밋으로 이동합니다.

---

## 브랜치 강제 이동

`-f` 옵션과 상대 참조를 사용하면, 브랜치를 특정 커밋으로 재지정할 수 있습니다.
예를 들어, `main` 브랜치를 현재 HEAD에서 3번 이전 커밋으로 이동시키려면:

```bash
git branch -f main HEAD~3
```

또한, `<브랜치명>`이나 `<커밋 해시>`를 직접 사용할 수도 있습니다.

---

## Git에서 작업 되돌리기

작업 내역을 되돌리는 방법에는 두 가지 주요 방식이 있습니다.

1. **git reset**  
   - 로컬 히스토리에서 커밋 자체를 제거하여, 커밋하지 않은 상태로 되돌립니다.
   - 예:  
     ```bash
     git reset HEAD~1
     ```
   - 주의: 이미 공유된 커밋을 reset하면 협업 시 문제가 발생할 수 있습니다.

2. **git revert**  
   - 기존 커밋의 변경 내용을 반대로 적용한 새로운 커밋을 생성하여, 변경 사항을 취소합니다.
   - 예:
     ```bash
     git revert HEAD
     ```
   - 이렇게 하면, 원래의 커밋은 그대로 유지되면서 반대 내용의 커밋(`C2'` 등)이 생성됩니다.

---

## Git Cherry-pick

**체리픽(Cherry-pick)** 은 특정 커밋 하나 또는 여러 개를 선택하여 현재 브랜치에 복사해오는 기능입니다.
예를 들어, `C2`와 `C4` 커밋만을 현재 브랜치에 적용하고 싶다면:

```bash
git cherry-pick C2 C4
```

체리픽은 rebase를 사용해서도 가능하지만, 명시적으로 특정 커밋만 선택할 때 유용합니다.

---

## Git Interactive Rebase

**인터랙티브 리베이스**는 `-i` 옵션을 사용하여 커밋 이력을 재구성하는 방법입니다.
- 커밋 순서를 바꾸거나, 원하지 않는 커밋을 제거하고, 여러 커밋을 하나로 스쿼시할 수 있습니다.
- 실행 명령어:
  ```bash
  git rebase -i [기준 커밋]
  ```
- 이 방법을 통해 디버깅용 커밋이나 불필요한 커밋들을 정리할 수 있습니다.

---

## 기존 커밋 내역 수정하기

개발 중 이전 커밋의 내용을 살짝 수정해야 할 경우, 다음과 같은 방법들을 사용할 수 있습니다.
- **git commit --amend**: 가장 최근 커밋을 수정합니다.
- **git rebase -i**: 여러 커밋을 대상으로 커밋 메시지 수정, 순서 변경, 스쿼시 등의 작업을 수행합니다.

---

## Git 태그

브랜치는 가변적인 참조인 반면, **태그(Tag)** 는 특정 커밋을 영구적인 마일스톤으로 표시합니다.
- 태그 생성:
  ```bash
  git tag v1 [커밋 해시]
  ```
  커밋 해시를 생략하면 현재 HEAD에 태그가 붙습니다.
- 태그와 커밋 간의 관계를 확인하기 위해:
  ```bash
  git describe [브랜치 or 커밋]
  ```
  출력 예시: `v1_3_gfed2` — 가장 가까운 태그(`v1`), 그 태그로부터의 커밋 수(`3`), 그리고 커밋 해시의 일부(`fed2`)

---

## 요약

지금까지 Git의 주요 개념에 대해 정리했습니다.

- **커밋**은 변경 사항의 스냅샷을 기록하며, 실제로는 변경된 내역(Delta)만 저장합니다.
- **브랜치**는 특정 커밋을 가리키는 포인터로, 작업 내역을 효율적으로 분리하고 관리할 수 있게 합니다.
- **머지**는 두 브랜치의 작업 내역을 통합한 새로운 병합 커밋을 생성합니다.
- **리베이스**는 커밋들을 복사하여 다른 브랜치 위에 재적용, 커밋 로그를 깔끔하게 정리합니다.
- **체리픽**은 원하는 특정 커밋만을 선택적으로 적용합니다.
- **인터랙티브 리베이스**를 통해 커밋 히스토리를 재구성할 수 있습니다.
- **태그**는 중요한 마일스톤 커밋을 영구적으로 표시하여 관리할 수 있습니다.
