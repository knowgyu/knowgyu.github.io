---
title: "[혼공컴운] 2장 데이터"
author: knowgyu
description: " "
date: 2024-07-12 06:53:10 +0900
math: true
categories: [Computer Science, 혼자 공부하는 컴퓨터구조+운영체제]
tags: [컴퓨터구조, 운영체제]
---

컴퓨터는 0과 1로 표현되는 것을 어떻게 다양한 숫자와 문자를 표현하는 지 학습

# 2-1 0과 1로 숫자를 표현하는 방법

키워드 : 비트, 바이트, 이진법, 2의 보수, 십육진법

---

컴퓨터는 0과 1로 모든 정보를 표현하고, 0과 1로 표현된 정보만을 이해할 수 있는데,

어떻게 3과 4를 인식하고 3+4 = 7이라는 결과를 내놓을 수 있을까?

## 정보 단위

컴퓨터가 이해하는 가장 작은 정보 단위는 0과 1을 나타내는 비트!

즉, 1비트는 2가지 상태를 나타낼 수 있다!

> 2비트는 00, 01, 10, 11 총 4(2*2)가지,<br>
>  3비트는 000, 001, … , 110, 111 총 8(2*2*2)가지
{: .prompt-tip }


즉, n개의 전구로 표현할 수 있는 상태는 $2^n$가지입니다.

하지만, 우리는 어떤 파일의 용량을 얘기할 때 “이 동영상은 4.2GB 크기야.” 라고 말함.

여기서 바이트는 8개의 비트를 묶은 단위로, 비트보다 한 단계 큰 단위입니다.

1 byte = 8bits

1 kB = 1000 bytes

1 MB = 1000 kBytes

…

```markdown
왜 1 byte = 8bits 인 가?에 대해서는 정확한 이유는 모르겠습니다.

초기에는 1 byte의 정의가 다양했으나, 컴퓨터를 이용해서 문자를 표현할 때,

아스키코드라는 체계를 이용했는데, 아스키코드가 7비트이며,

IBM 360 시리즈는 8-bit byte로 개발되었고, 그 구조가 지금까지 전해진 것이라 생각합니다.
```

> 워드(word)<br>
<br>
워드란 CPU가 한 번에 처리할 수 있는 데이터 크기를 의미합니다.<br>
만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되는 것입니다.<br>
<br>
현대 컴퓨터의 워드 크기는 대부분 32비트 혹은 64비트로,<br>
인텔의 x86 CPU는 32비트 워드 CPU, x64 CPU는 64비트 워드 CPU입니다.<br>
{: .prompt-tip }



## 이진법

이진법의 설명은 넘어가겠습니다.

### 이진수의 음수 표현

0과 1만으로 음수를 표현하기 위해, 2의 보수를 구해 이 값을 음수로 간주하는 방법을 사용합니다.

2의 보수의 사전적 의미는 아래와 같습니다.

> 어떤 수를 그보다 큰 $2^n$에서 뺀 값
> 

즉, 2진수 11의 보수는 100에서 11을 뺀 01이 되는 것입니다.

하지만, 쉽게 표현하자면

> 모든 0과 1을 뒤집고, 거기에 1을 더한 값
> 

이라 생각하면 됩니다.

그렇다면, “-1011을 표현하기 위해 0101을 표현하는 것과, 5를 표현하기 위해 0101은 똑같이 생겼는데, 어떻게 구분하는가?”에 대해서는 플래그를 사용합니다.

우선, 양수와 음수를 구분할 수 있도록 플래그가 있기에 CPU가 부호를 헷갈릴 일은 없다고 생각하고, 넘어가겠습니다.


> 2의 보수표현의 한계
>
>만약 0을 음수로 표현하면 1도 되지만, 10, 100, 1000 … 과 같은 표현이 될 수 있으며
>
>1000을 음수로 표현하면 똑같이 1000으로 표현됩니다.
>
>첫번째 경우에서는 자리올림으로 인해 1을 버릴 수 있으며,
>두번째 경우에선 n비트로 -2^n과 2^n을 동시에 표현할 수 없는 문제가 있습니다.
{: .prompt-tip }

## 십육진법

16진법에 대해서도 넘어가겠습니다.

```markdown
16진법을 사용하는 이유는, 2진수를 간단하게 표현할 수 있기 때문입니다.

예를 들어, 10진수 15는 2진수로 표현하면 1111이지만, 16진수로 표현하면 F 입니다.

여기서, 1바이트를 2진수로 표현하면 1110 1111 이지만, 16진수로 표현하면 EF 입니다.

이처럼 16진수를 이용하면 1바이트를 매우 간단하게 표현할 수 있기 때문에 사용합니다.

단, 여기서 16진수를 구분하기 위해 0xF, 0xEF 와 같이 0x를 붙입니다.
(2진수도 똑같이 0b를 사용하기도 함)
```

# 2-2 0과 1로 문자를 표현하는 방법

키워드 : 문자 집합, 아스키 코드, EUC-KR, 유니코드

---

이번 절에서는 0과 1로 문자를 표현하는 방법에 대해 알아보겠습니다.

## 문자 집합과 인코딩

0과 1을 문자로 표현하는 방법을 알기 위해선, `문자 집합`, `인코딩`, `디코딩`에 대해 알아야 합니다.

- 문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
    
    ex) 문자 집합이 {a, b, c, d, e}일 경우 이 5가지 문자는 이해할 수 있으나, f는 이해하지 못함.
    

- 문자 인코딩 : 문자를 숫자로 변환하는 과정
    
    문자 집합에 속한 문자가 있다고 그대로 이해할 수 있는건 아님. 문자를 0과 1로 변환해야 비로소 이해할 수 있게 됨.
    

- 문자 디코딩 : 숫자를 문자로 변환하는 과정
    
    반대로, 숫자를 문자로 변환하는 과정입니다.
    

## 아스키 코드(ASCII)

(American Standard Code for Information Interchange)

영어 알파벳과 아라비아 숫자, 그리고 일부 특수 문자를 포함하는 **문자 집합**입니다.

아스키 문자는 7비트로 표현되는데, 즉 $2^7$개인 128개의 문자를 표현할 수 있습니다.


> 실제로는 아스키 문자를 나타내기 위해 8비트(1바이트)를 사용합니다.
> 7비트는 아스키 문자를 표현하며, 1비트는 패리티 비트(parity bit)라 불리는
> 오류 검출을 위해 사용되는 비트가 있습니다.
{: .prompt-info }

### +) 기억해두면 좋을 아스키 코드표

| 문자 | 십진수(코드 포인트) |
| ---- | ------------------- |
| 0    | 48                  |
| A    | 65                  |
| a    | 97                  |

> 물론, 대소문자를 변경하는 상황에서 `ans = X - 'a' + 'A';` 와 같은 형태로 할 수 있겠지만,
기본적으로 위 값들은 알아두는게 좋았던 것 같습니다.

아스키코드는 매우 간단하게 인코딩되는 장점이 있지만, 한글을 표현할 수 없다는 단점이 있음.

이후 1비트를 추가해 8비트의 **확장 아스키**가 등장했지만, 그럼에도 256 문자는 턱없이 부족했음.

→ EUC-KR, 유니코드와 같은 인코딩 방식 등장

## EUC-KR

영어 인코딩과 달리, 한글은 초성, 중성, 종성의 조합으로 이루어져 있음.

따라서, 한글 인코딩에는 두 가지 방식이 있음.

1. 완성형(한글 완성형 인코딩 ex. ‘강’, ‘민’, ‘철’)
2. 조합형(한글 조합형 인코딩 ex. ‘ㄱ’ + ‘ㅏ’ + ‘ㅇ’)

**EUC-KR**은 대표적인 **완성형 인코딩 방식**입니다.

즉, 초성, 중성, 종성이 모두 결합된 한글 단어에 2바이트 크기의 코드를 부여합니다.

2바이트 → 16비트 → 네 자리 16진수로 표현할 수 있습니다.

EUC-KR 인코딩 방식으로 총 2,350개 정도의 한글 단어를 표현할 수 있습니다.

하지만, 그럼에도 ‘쀍’, ‘쀓’, ‘믜’와 같은 글자는 EUC-KR로 표현할 수 없습니다.

이로 인해, EUC-KR 인코딩을 사용하는 웹사이트의 한글이 깨지거나, EUC-KR로는 표현할 수 없는 이름으로 인해 은행, 학교 등에서 피해를 받는 사람이 생기기도 했습니다.

이를 조금이나마 해결하고자 등장한 것이 MS의 **CP949**(EUC-KR의 확장버전) 입니다.

하지만, 그럼에도 불구하고 한글 전체를 표현할 수 없었습니다.

## 유니코드와 UTF-8

EUC-KR 인코딩 덕분에 한글을 표현할 수 있지만, 모든 한글을 표현할 수 없다는 문제가 있습니다.

또한, 이렇게 언어별로 인코딩한다면 다국어를 지원하는 프로그램을 만들 때 어려움이 있습니다.

모든 언어를 아우르는 문자 집합과 통일된 표준 인코딩 방식이 필요 → **유니코드**의 등장

아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았습니다.

하지만, 유니코드는 글자에 부여된 값 자체를 인코딩하지 않고, 다양한 방법으로 인코딩합니다.

(UTF-8, UTF-16, UTF-32등, UTF = Unicode Transformation Format)

UTF-8은 1~4바이트까지의 인코딩 결과를 만들어 냅니다.

즉, 인코딩한 값의 결과는 1바이트가 될 수도, 2,3,4 바이트가 될 수도 있습니다.

---
---
---

> 위 내용은 한빛미디어의 "혼자 공부하는 컴퓨터 구조+운영체제" 교재를 학습하고, 정리한 글입니다.
{: .prompt-tip }
