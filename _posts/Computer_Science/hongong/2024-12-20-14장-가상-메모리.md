---
title: "[혼공컴운] 14장 가상 메모리"
author: knowgyu
description: " "
date: 2024-09-20 07:30:00 +0900
categories: [Computer Science, 혼자 공부하는 컴퓨터구조+운영체제]
tags: [메모리 관리, 연속 메모리 할당, 스와핑]
---

# 14-1 연속 메모리 할당

운영체제의 **메모리 관리** 방식 중 하나로, 프로세스에 **연속적인 메모리 공간**을 할당하는 방식을 설명합니다.  
이 절에서는 **스와핑**, **메모리 할당 전략**, 그리고 **외부 단편화** 문제를 다룹니다.

---

## 스와핑 (Swapping)

메모리에는 **실행 중인 프로세스**만이 적재되어야 합니다.  
그런데 입출력 작업을 기다리거나 **오랫동안 사용되지 않는 프로세스**도 메모리에 있을 수 있습니다.  

**스와핑**은 이러한 프로세스를 **보조기억장치**의 일부 영역으로 **옮겨서** 메모리를 확보하는 방식입니다.

- **스왑 영역 (Swap Space)**: 보조기억장치의 스와핑을 위한 영역입니다.  
- **스왑 아웃 (Swap Out)**: 프로세스를 **메모리 → 스왑 영역**으로 옮기는 동작입니다.  
- **스왑 인 (Swap In)**: 프로세스를 **스왑 영역 → 메모리**로 다시 옮기는 동작입니다.  

> 스왑된 프로세스는 **다른 물리 주소**에 적재될 수 있습니다.  
{: .prompt-info }

> **유닉스 기반 시스템**에서는 `free`, `top` 명령어를 사용해 **스왑 영역의 크기**를 확인할 수 있습니다.  
{: .prompt-tip }

---

## 메모리 할당 전략

프로세스는 메모리의 **빈 공간**에 할당되어야 합니다.  
여러 개의 빈 공간이 있을 때, 프로세스를 어디에 배치하는 것이 효율적일까요?  
대표적인 방법은 **최초 적합**, **최적 적합**, **최악 적합**이 있습니다.

---

### 1. 최초 적합 (First Fit)

- **동작 원리**: 메모리의 **빈 공간을 순서대로 검색**하며, **적합한 공간을 발견**하면 바로 할당합니다.  
- **장점**: 검색 시간을 최소화하여 **빠른 할당**이 가능합니다.

### 2. 최적 적합 (Best Fit)

- **동작 원리**: **모든 빈 공간을 검색**한 후, 프로세스를 할당할 수 있는 **가장 작은 빈 공간**에 배치합니다.  
- **장점**: 메모리 낭비를 최소화할 수 있습니다.

---

### 3. 최악 적합 (Worst Fit)

- **동작 원리**: **모든 빈 공간을 검색**한 후, 프로세스를 할당할 수 있는 **가장 큰 빈 공간**에 배치합니다.  
- **장점**: 큰 빈 공간이 남아 있어 **추후 큰 프로세스**를 할당할 수 있습니다.

## 외부 단편화 (External Fragmentation)

연속 메모리 할당 방식은 **외부 단편화** 문제를 초래할 수 있습니다.

- **외부 단편화**: 메모리의 **빈 공간이 여러 조각**으로 나뉘어, 프로세스가 할당되기 어려워지는 현상입니다.  

**예시**:  
프로세스가 100MB의 메모리를 요구하지만, 빈 공간이 **50MB씩 6칸**으로 나뉘어 있으면,  
총 300MB의 빈 공간이 있어도 프로세스를 적재할 수 없습니다.

> **외부 단편화**는 메모리 공간을 비효율적으로 사용하게 만듭니다.  
{: .prompt-warning }

---

### 해결 방법: 메모리 압축 (Compaction)

**메모리 압축**은 흩어져 있는 작은 빈 공간들을 **하나로 모아** 큰 공간을 만드는 방식입니다.  
이 방식을 **메모리 조각 모음**이라고도 합니다.

- **장점**: 외부 단편화 문제를 해결할 수 있습니다.  
- **단점**: 메모리 내용을 옮기는 동안 **시스템이 중지**되며, **오버헤드**가 발생합니다.

---

## 가상 메모리와 페이징 기법

**외부 단편화 문제**를 근본적으로 해결하기 위해 **가상 메모리**와 **페이징 기법**이 등장하게 되었습니다.

> **페이징 기법**은 연속적인 메모리 할당을 **비연속적**으로 관리할 수 있도록 하는 기법입니다.  
{: .prompt-tip }

---

# 14-2 페이지를 통한 가상 메모리 관리

---

## 가상 메모리와 페이징

**가상 메모리**는 실행하려는 프로그램의 일부만 메모리에 적재해도, **실제 물리 메모리보다 큰 프로그램**을 실행할 수 있게 해주는 기술입니다.  

이를 위해 사용하는 대표적인 기법은 **페이징(Paging)**입니다.

> **페이징 기법의 장점**:  
> - 외부 단편화 문제를 해결합니다.  
> - 메모리를 **불연속적으로 할당**할 수 있습니다.  
{: .prompt-tip }

---

## 페이징이란?

**페이징**은 메모리와 프로세스를 **일정한 크기**로 잘라서 할당하는 기법입니다.

- **페이지(Page)**: 프로세스의 **논리 주소**를 일정한 단위로 나눈 조각입니다.  
- **프레임(Frame)**: 메모리의 **물리 주소**를 페이지와 동일한 크기로 나눈 조각입니다.  

페이징은 **페이지 단위**로 **페이지 인/아웃**이 이루어지기 때문에, **프로세스 전체를 메모리에 적재할 필요가 없습니다**.  

---

## 페이지 테이블 (Page Table)

페이징 기법을 사용하면 **프로세스의 페이지**가 **메모리의 여러 프레임**에 **불연속적으로 저장**됩니다.  
CPU가 명령어를 실행하기 위해 페이지가 **어느 프레임에 위치하는지**를 알려주는 **페이지 테이블**이 필요합니다.

- **페이지 테이블**: **페이지 번호**와 **프레임 번호**를 매핑하는 테이블입니다.  
- **페이지 테이블 베이스 레지스터 (PTBR)**: 페이지 테이블이 저장된 **메모리 주소**를 저장합니다.

---

> **페이지 테이블의 문제**  
> 페이지 테이블은 **메모리에 저장**되기 때문에 CPU가 접근할 때마다 **메모리 접근 시간이 증가**합니다.  
{: .prompt-warning }

---

## TLB (Translation Lookaside Buffer)

**페이지 테이블 접근 시간**을 줄이기 위해 **페이지 테이블의 캐시** 역할을 하는 **TLB**가 사용됩니다.

- **TLB**: MMU(메모리 관리 장치) 내에 위치한 **캐시 메모리**입니다.  
- **TLB 히트**: 원하는 페이지가 TLB에 존재하여 **빠르게 접근**할 수 있습니다.  
- **TLB 미스**: 원하는 페이지가 TLB에 존재하지 않아 **페이지 테이블**에 접근해야 합니다.

> **참조 지역성 원리** 덕분에 TLB는 페이지 테이블 접근 속도를 크게 개선할 수 있습니다.  
{: .prompt-info }

---

## 페이징에서의 주소 변환

페이징 시스템에서 논리 주소는 **페이지 번호(Page Number)**와 **변위(Offset)**로 구성됩니다.

**주소 변환 과정**  

1. **페이지 번호**를 사용해 **페이지 테이블**에서 해당 페이지가 저장된 **프레임 번호**를 찾습니다.  
2. **프레임 번호**와 **변위**를 조합해 **물리 주소**를 생성합니다.  

---

### **주소 변환 예시**

| **논리 주소** | **페이지 번호** | **변위** |
| ------------- | --------------- | -------- |
| `2056`        | `2`             | `56`     |

1. 논리 주소 `2056` → 페이지 크기가 `1000`이라면:  
   - 페이지 번호 = `2056 / 1000` = `2`  
   - 변위 = `2056 % 1000` = `56`  

2. **페이지 테이블**에서 페이지 `2`의 프레임 번호를 확인합니다.  
   - 예: 페이지 `2` → 프레임 `5`  

3. 물리 주소 = **프레임 번호** × **페이지 크기** + **변위**  
   - 물리 주소 = `5 × 1000 + 56 = 5056`  

> **결론**: 논리 주소 `2056`은 물리 주소 `5056`으로 변환됩니다.  
{: .prompt-tip }

---

## 페이지 테이블 엔트리 (Page Table Entry)

페이지 테이블은 단순히 페이지 번호와 프레임 번호만 저장하지 않습니다.  
추가적으로 **페이지 보호** 및 **상태 정보**를 나타내는 **페이지 테이블 엔트리 (PTE)**가 있습니다.

| **비트**      | **설명**                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------- |
| **유효 비트** | 페이지가 메모리에 적재되었는지 여부를 나타냅니다. (`1`: 메모리에 있음, `0`: 스왑 영역에 있음) |
| **보호 비트** | 페이지의 접근 권한을 나타냅니다. (`R`: 읽기, `W`: 쓰기, `X`: 실행)                            |
| **참조 비트** | CPU가 페이지에 접근했는지를 나타냅니다. (`1`: 접근됨, `0`: 접근되지 않음)                     |
| **수정 비트** | 페이지가 수정되었는지 여부를 나타냅니다. (`1`: 수정됨, `0`: 수정되지 않음)                    |

---

### 페이지 폴트 (Page Fault)

- **페이지 폴트**: CPU가 접근한 페이지가 **메모리에 존재하지 않을 때** 발생하는 예외입니다.  
- **동작 과정**:  
  1. 페이지 폴트 발생  
  2. 스왑 영역에서 해당 페이지를 메모리로 가져옵니다.  
  3. 페이지 테이블을 업데이트한 후, 다시 프로세스를 실행합니다.

> 페이지 폴트는 하드웨어 인터럽트 처리와 유사하게 동작합니다.  
{: .prompt-info }

---

> **페이징의 장단점**  
> - **장점**: 외부 단편화를 해결하고 메모리를 효율적으로 사용할 수 있습니다.  
> - **단점**: 내부 단편화가 발생할 수 있습니다.  
{: .prompt-warning }

---

# 14-3 페이지 교체와 프레임 할당

---

## 요구 페이징 (Demand Paging)

**요구 페이징**은 **프로세스의 모든 페이지**를 메모리에 적재하지 않고, **필요한 페이지만 적재**하는 방식입니다.

### 요구 페이징의 동작 과정

1. CPU가 **특정 페이지**에 접근하는 명령을 실행합니다.  
2. 페이지가 **메모리에 존재**하면(유효 비트 `1`), CPU는 해당 프레임에 접근합니다.  
3. 페이지가 **메모리에 존재하지 않으면**(유효 비트 `0`), **페이지 폴트**가 발생합니다.  
4. **페이지 폴트 처리 루틴**이 스왑 영역에서 해당 페이지를 메모리로 적재하고, 유효 비트를 `1`로 설정합니다.  
5. 다시 1번으로 돌아가 CPU는 해당 페이지를 실행합니다.

> **순수 요구 페이징 (Pure Demand Paging)**  
> 아무런 페이지도 메모리에 적재하지 않고 **실행부터 시작**하는 방식을 말합니다.  
{: .prompt-tip }

---

## 페이지 교체 알고리즘

요구 페이징 시스템에서는 메모리가 **가득 차게 되면** 새로운 페이지를 적재하기 위해 **기존 페이지를 교체**해야 합니다.  
어떤 페이지를 교체할지 결정하는 방법이 **페이지 교체 알고리즘**입니다.

---

### 1. FIFO 페이지 교체 알고리즘 (First-In-First-Out)

- **동작 원리**:  
  메모리에 가장 **먼저 들어온 페이지**를 교체합니다.  
- **장점**:  
  - 구현이 단순합니다.  
- **단점**:  
  - 오래된 페이지라고 해서 **필요하지 않은 페이지**라고 단정할 수 없습니다.  

### 2. 최적 페이지 교체 알고리즘 (Optimal Page Replacement)

- **동작 원리**:  
  앞으로 **가장 오랫동안 사용되지 않을 페이지**를 교체합니다.  
- **장점**:  
  - **가장 낮은 페이지 폴트율**을 보장합니다.  
- **단점**:  
  - **미래의 페이지 참조를 예측해야 하기 때문에** 실제 구현이 불가능합니다.  

> **비유**:  
> "앞으로 한동안 쓰지 않을 페이지"를 예측해서 교체하는 가장 이상적인 방법입니다.  
{: .prompt-info }

### 3. LRU 페이지 교체 알고리즘 (Least Recently Used)

- **동작 원리**:  
  **가장 오랫동안 사용되지 않은 페이지**를 교체합니다.  
- **특징**:  
  - 최근에 사용되지 않은 페이지는 **앞으로도 사용되지 않을 가능성이 높다**는 가정입니다.  
- **단점**:  
  - 높은 오버헤드

> 즉, 페이지 교체 알고리즘 역시 하나의 만능 키는 존재하지 않습니다.  
> 각 알고리즘이 어떤 아이디어인지에 집중하면 좋을 것이라 생각합니다.
{: .prompt-info }


## 스래싱과 프레임 할당

### 스래싱 (Thrashing)

**스래싱**이란 프로세스가 실행되는 시간보다 **페이지 교체에 더 많은 시간**을 소모하여 성능이 저하되는 현상입니다.

- **발생 원인**: 프로세스가 필요로 하는 **최소한의 프레임 수**를 확보하지 못할 때 발생합니다.  

> **예시**:  
> 물리 메모리는 `10KB`인데, 페이지가 `10KB × 1000개` 있다면 페이지 교체가 계속 발생해 **CPU 이용률**이 크게 저하됩니다.  
{: .prompt-warning }

---

### 프레임 할당 방식

메모리의 **프레임을 어떻게 각 프로세스에 할당할지** 결정하는 방식입니다.

#### 1. 균등 할당 (Equal Allocation)

- **정의**: 모든 프로세스에 **동일한 수의 프레임**을 할당합니다.  
- **단점**: 각 프로세스의 **프레임 요구량**을 고려하지 않기 때문에 비효율적입니다.

#### 2. 비례 할당 (Proportional Allocation)

- **정의**: 프로세스의 크기에 **비례해서** 프레임을 할당합니다.  
- **특징**: 크기가 큰 프로세스는 더 많은 프레임을 할당받습니다.  

> 하지만, 꼭 프로세스가 크다고 많은 프레임을 사용할 것이라는 보장은 없습니다.
{: .prompt-warning}

---

## 프레임 요구량 결정 방식

프레임의 할당량을 동적으로 조정하는 방법에는 **작업 집합 모델**과 **페이지 폴트 빈도** 방식이 있습니다.

---

### 1. 작업 집합 모델 (Working Set Model)

- **정의**: 프로세스가 일정 시간 동안 **자주 참조하는 페이지 집합**을 **작업 집합**이라고 합니다.  
- **작동 원리**:  
  - 프로세스에 **작업 집합 크기**만큼 프레임을 할당합니다.  
  - 작업 집합이 메모리에 존재하면 **페이지 폴트가 줄어들어** 성능이 개선됩니다.  

> 자주 사용하는 데이터만 **메모리**에 두고 나머지는 **보조 기억장치**로 옮기는 방식입니다.  
{: .prompt-tip }

---

### 2. 페이지 폴트 빈도 (Page-Fault Frequency, PFF)

- **정의**: 페이지 폴트가 발생하는 **빈도**를 기준으로 프레임을 조정하는 방식입니다.  
- **작동 원리**:  
  - 페이지 폴트 빈도가 **높으면** 더 많은 프레임을 할당합니다.  
  - 페이지 폴트 빈도가 **낮으면** 프레임을 회수합니다.

> **목표**: 페이지 폴트 빈도를 일정한 수준으로 유지하면서, **최적의 프레임 수**를 할당합니다.  
{: .prompt-info }



> 정리하자면 스래싱을 방지하기 위해 **프레임 수** 를 동적으로 **적절하게 조정**하는 것이 중요합니다.  
{: .prompt-tip }

---

> 위 내용은 한빛미디어의 "혼자 공부하는 컴퓨터 구조+운영체제" 교재를 학습하고 정리한 글입니다.  
{: .prompt-tip }
