---
title: "[임베교과서] 4장 임베디드 시스템을 사용한 C언어 프로그래밍 (2)"
author: knowgyu
description: " "
date: 2025-01-02 17:38:00 +0900
categories: [Embedded System, 임베디드 엔지니어 교과서]
tags: [Embedded System, 임베디드 엔지니어 교과서]
---

## Blink 프로그램 이해하기

이전 페이지에서 간단히 **Blink 프로그램**을 작성해 보았습니다.  
이번에는 그 코드를 **어셈블리 레벨**에서 살펴보면서, **레지스터 제어**가 어떻게 이루어지는지 간단히 확인해 보겠습니다.

---

### CPU의 관점에서 바라본 레지스터 제어

**ATmega328P**(아두이노 우노에 탑재된 MCU)의 경우, **I/O Mapped I/O** 방식을 사용합니다.  
- C 같은 고급 언어에서는 `DDRB`, `PORTB` 등의 **매크로**만 보면 되지만,  
- 어셈블리어 관점에서는 **특정 명령어**(예: `ld`, `st`)를 통해 **I/O 공간**에 접근하는 형태로 보이게 됩니다.

---

### 어셈블러에서 확인

직접 **어셈블리**를 확인하기 위해, 이전에 빌드한 **ELF 파일**(예: `blink.elf`)을 `avr-objdump`로 디스어셈블해 보겠습니다.

```bash
avr-objdump -S blink.elf > blink.s
```

이제 `blink.s` 파일을 열어 보면, `DDRB`나 `PORTB`에 값을 쓰는 부분이 어셈블리 코드로 어떻게 표현되는지 볼 수 있습니다.

> 전체 코드는 아래 레포 ch4 디렉터리에 있습니다.
> [https://github.com/knowgyu/embedded-textbook](https://github.com/knowgyu/embedded-textbook)

#### 예시 코드 (DDRB 제어 부분)

```plaintext
DDRB |= (1<<PB1);
  8a:   84 e2         ldi     r24, 0x24   ; 36
  8c:   90 e0         ldi     r25, 0x00   ; 0
  8e:   24 e2         ldi     r18, 0x24   ; 36
  90:   30 e0         ldi     r19, 0x00   ; 0
  92:   f9 01         movw    r30, r18
  94:   20 81         ld      r18, Z
  96:   22 60         ori     r18, 0x02   ; 2
  98:   fc 01         movw    r30, r24
  9a:   20 83         st      Z, r18
```

위 코드를 보면 r25, r24와 같은 것들이 있는데 이는 CPU 내장 레지스터입니다.  

**r00~r31**: CPU 내부의 범용 레지스터  
- **r26~r31**: 특히 X, Y, Z **인덱스 레지스터**로 사용 가능 (간접 주소 지정 지원)

![alt text](/assets/img/ebtb/eb49.png)

위 이미지처럼 **r26~r31**은 간접 주소 지정에 특화되어 있으며, 실제로 **Z 레지스터**(r30, r31 쌍)가 **외부 I/O 공간**에 접근할 때 사용됩니다.


### 명령어 설명

1. **`ldi` 명령**  
   `ldi r24, 0x24`처럼, **실제 값(immediate value)**자체를 직접 레지스터(r24)에 적재하는 방식입니다.  
   아래 예시의 첫 4행에서는 `r24, r25`와 `r18, r19` 각각에 **0x0024** 값을 담아, DDRB를 제어하기 위한 준비를 합니다.

   ```
   8a:	84 e2       	ldi	r24, 0x24	; 36
   8c:	90 e0       	ldi	r25, 0x00	; 0
   8e:	24 e2       	ldi	r18, 0x24	; 36
   90:	30 e0       	ldi	r19, 0x00	; 0
   ```

   > 레지스터에 16비트 주소 0x0024를 담아야합니다. 하지만, ATmega328P는 8비트 CPU이며, r00~r31은 각각 8비트 레지스터이기에 r25에 0x00, r24에 0x24를 나눠 담는 방식입니다.
   {: .prompt-tip }

1. **`movw` 명령**  
   **16비트(word) 단위**로 레지스터 간 데이터를 복사합니다.  
   예: `movw r30, r18`라고 쓰면, 실제론 `r30, r31 ← r18, r19`가 되어 **0x0024**가 `r30`과 `r31`(Z 레지스터)에 옮겨집니다.  
   즉, Z 레지스터가 설정되는 것이죠.

   ```
   92:	f9 01       	movw	r30, r18
   ```

2. **`ld` 명령**  
   `ld r18, Z`는 **Z 레지스터**에 들어 있는 **간접 주소**를 통해 값을 읽어 `r18`에 저장합니다.  
   여기서 Z 레지스터에는 0x0024가 있으므로, 결과적으로 **0x0024번지**에 있는 데이터를 r18에 가져오게 됩니다.

   ```
   94:	20 81       	ld	r18, Z
   ```

3. **`ori` 명령**  
   r18 레지스터의 내용과 `0x02`를 **OR 연산**합니다.  
   즉, 0x0024번지에서 읽어 온 값에 0x02를 OR해, PB1 비트를 설정하는 셈입니다.

   ```
   96:	22 60       	ori	r18, 0x02	; 2
   ```

4. **`movw` 명령**  
   앞서와 동일하게, `movw r30, r24` 등을 통해 r24, r25에 있던 주소를 다시 `r30, r31`(Z 레지스터)로 옮깁니다.

   ```
   98:	fc 01       	movw	r30, r24
   ```

5. **`st` 명령**  
   `st Z, r18`는 **Z 레지스터가 가리키는 번지(0x0024)**에 `r18`의 내용을 기록합니다.  
   즉, OR 연산 결과를 0x0024번지(DDRB 레지스터)에 최종적으로 써 넣는 과정입니다.

   ```
   9a:	20 83       	st	Z, r18
   ```

결국, **DDRB 제어**는 0x0024번지에 있는 **I/O 레지스터**에 값을 쓰는 방식임을 알 수 있고,  
**PORTB**도 비슷하게 **0x0025** 번지에 기록함으로써 GPIO 출력을 제어합니다.

---

### 요약

내부 범용 레지스터(r24, r25, r18, r19 등)를 활용해 **DDRB, PORTB** 레지스터 주소(0x0024, 0x0025)를 보관해 두고,  
이 주소를 **Z 레지스터**(r30, r31)에 설정하여 **CPU 외부**(I/O 공간)의 주변장치 레지스터를 간접적으로 제어하게 됩니다.  
즉,

1. **제어 대상 레지스터**의 번지(0x0024, 0x0025 등)를 CPU 내장 레지스터에 로드  
2. 그 번지를 **Z 레지스터**에 옮겨 간접 주소를 설정  
3. **데이터 버스**를 통해 외부 I/O 레지스터에 읽기/쓰기 작업 수행

이 과정을 거쳐 **GPIO 핀**(PB1 등)을 제어해 LED를 켜거나 끄는 동작을 완성하게 됩니다.


> 책에서는 간단하게 delay 사용에 대해 다루지만, 일단 넘어가고 추후에 링크를 추가하겠습니다.

---

> 위 내용은 **제이펍**의 "**임베디드 엔지니어 교과서**"를 읽고 공부한 것을 정리한 글입니다.  
> 저자명 : 와타나베 노보루, 마키노 신지 / 역자명 : 정인식
{: .prompt-tip }
